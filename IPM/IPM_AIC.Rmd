---
title: "Integrated Population Model"
author: "Eric Imbert & Loïc Pages"
date: "`r Sys.Date()`"
output:
  html_document:
    df_print: paged
  word_document: default
  pdf_document: default
---

# Initialisation
```{r}
rm(list=ls())
library(knitr)
library(spaMM)
library(tidyverse)
library(popbio)
library(splines)

setwd("/media/loic/Commun/0Travail/Stage 2025 ISEM/Models/IPM")

# centauree_data <- read.csv("donnesIPM_short.csv")
# IPM_data <- read.csv("donnesIPM.csv")
GrowthRateMPM <- read.csv("Growth.rates.csv",sep = " ",dec = ",")

MatrixDim <- 50
RecrRate <- 0.2055 #recruitment rate

#Forcer l'age maximal à 8
AgeMax <- 8
# centauree_data$age1 <- ifelse(centauree_data$Stage1=="V",centauree_data$Age+1,NA)
# centauree_data$Age[centauree_data$Age > AgeMax] <- AgeMax
# centauree_data$age1[centauree_data$age1 > AgeMax] <- AgeMax

IPM_data <- read.csv("newdata.csv")

IPM_data$Age[IPM_data$Age > 8] <- 8

centauree_data <- IPM_data[!is.na(IPM_data$Size0Mars) & !is.na(IPM_data$Age),]

spaMM.options(separation_max=70)
```

Age of flowering plants - will be used later to compute optimal growth rate
```{r}
weightAgeFlrPool=NULL
for ( a in 1:AgeMax ) {
  weightAgeFlrPool[a]= nrow(centauree_data[which(centauree_data$Age==a & centauree_data$Flowering==1),])
}
```

Seedling size distribution
```{r}
plantule_data <- IPM_data[IPM_data$Age==1,] %>% 
  filter(!is.na(Age)) %>% 
  filter(Size0Mars!=0)

n_plt <- length(plantule_data$Individu)

sizeSeedl <- unique(plantule_data$Size0Mars[order(plantule_data$Size0Mars)])

Width <-NULL 
Den <- NULL 

for (i in 1:length(sizeSeedl)){
  # Number of observations for each size
  Width[i] <- length(unique(plantule_data$Individu[plantule_data$Size0Mars==sizeSeedl[i]]))
  # Frequency of each size
  Den[i] <- Width[i]/n_plt
}
Width
Den
dens <- rep(Den,Width)

gg1=lm(log(1/dens)~rep(sizeSeedl,Width))

densSeedl2=function(y,intervalle){   
  miny=min(y)
  maxy=max(y)
  SeedlgSize=exp(log(coef(gg1)[2])-y*coef(gg1)[2])/(exp(-coef(gg1)[2]*(miny-intervalle/2))-exp(-coef(gg1)[2]*(maxy+intervalle/2)))
  return(SeedlgSize)
}
```

## Models

Load the false data set which contains the predicted responses for survival probability, flowering probability, number of capitules (fecondity) and growth. There is a value of each of these response for each combination of size, age, population and year.
```{r}
## Creation of fake data
AgeMax <- 8
year <- 1995:2022
Pop <- c("Po","Au","Pe","E1","E2","Cr")
taille_range <- seq(0.5, 25, by = 0.5) 
age_range <- 1:AgeMax
# 
# fake_data <- expand.grid(
#   year = annees,
#   Pop = populations,
#   Size0Mars = NA,
#   Age = NA)


Pop=gl(6,length(year),labels = Pop)
rer=data.frame(Pop,year)
rer$Index=1:(length(year)*6)
fake_data=do.call("rbind", replicate(MatrixDim, rer, simplify = FALSE))
fake_data=fake_data[order(fake_data$Index),]
fake_data$Size0Mars=NA
fake_data$Age=NA

rm(rer, Pop, year)

load("ModelsAIC")

growthdata <- centauree_data[!is.na(centauree_data$Size1Mars), ]
growthdata <- growthdata[growthdata$Size1Mars != 0, ]
growthdata <- growthdata[!is.na(growthdata$Age),]
```

Creation of the functions for the kernels. 
```{r}
annees <- 1995:2022
populations <- c("Po","Au","Pe","E1","E2","Cr")

#Fecundity
numbofcap <- function(x, a) {
  fake_data <- expand.grid(
  year = annees,
  Pop = populations,
  Size0Mars = x,
  Age = a)
  mu <- exp(predict(Cptlglm1, fake_data))
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean)
  nbcap <- ifelse(mu2$V1>=0,mu2$V1,0)
  return(matrix(nbcap, length(x), length(x), byrow = T))
}

#Survival Probability for age 1
sx01 <- function(x,a) {
  fake_data <- expand.grid(
  year = annees,
  Pop = populations,
  Size0Mars = x,
  Age = a)
  mu <- predict(Survglm11, fake_data, allow.new.levels = T)
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean)
  return(mu2$V1)
}

#Survival Probability for age > 1
sx02 <- function(x, a) {
  fake_data <- expand.grid(
  year = annees,
  Pop = populations,
  Size0Mars = x,
  Age = a)
  mu <- predict(Survglm12, fake_data, allow.new.levels = T)
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean)
  return(mu2$V1)
}


#Flowering Probability
#Beta = will be used to modify the intercept of the flowering function
#obs_beta = observed value
#extract Beta0
load("obs_beta")
load("se_obs_beta")


#Flowering function for The survival-growth kernel
flr0 <- function(x, a, Beta) {
  fake_data <- expand.grid(
  year = annees,
  Pop = populations,
  Size0Mars = unique(x),
  Age = a)
  mu <- plogis(predict(Flowglm1, newdata = fake_data, allow.new.levels = T, type = "link") + Beta)
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean)
  return(mu2$V1)
}

#Flowering function for fecundity fyx0 - same function the difference is in the format of the output
flr1 <- function(x, a, Beta) {
  fake_data <- expand.grid(
  year = annees,
  Pop = populations,
  Size0Mars = unique(x),
  Age = a)
  mu <- plogis(predict(Flowglm1, fake_data, allow.new.levels = T, type = "link") + Beta)
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean)
  return(matrix(mu2$V1, MatrixDim, MatrixDim, byrow = T))
}

# Growthglm1 <- fitme(log(Size1Mars) ~ 1 + poly(log(Size0Mars),4), data=growthdata, resid.model = ~ 1)
#  
# Growthglm1 <- fitme(sqrt(Size1Mars) ~ 1 + poly(Size0Mars,4) + poly(Age,3) + (Size0Mars|year) + (Size0Mars|Pop),
#                     data=growthdata,
#                     resid.model =~log(Size0Mars))

sizesObserved=sort(unique(centauree_data$Size0Mars, na.rm=T))
SD=NULL
for (i in 1:length(sizesObserved)){
  SD[i]=sd(centauree_data$Size1Mars[which(centauree_data$Size1Mars !=0 & centauree_data$Size0Mars==(sizesObserved[i]))])}
  SD=SD[which(SD!=0)]
  sizesObserved=sizesObserved[which(SD!=0)]
  SDlm=lm(SD ~ sizesObserved)

# growthdata <- centauree_data %>%
#   filter(!is.na(Size1Mars),Size1Mars!=0,!is.na(Age)) %>%
#   mutate(logSize1Mars = log(Size1Mars),
#          logSize0Mars = log(Size0Mars))
# sizesObserved=sort(unique(growthdata$logSize0Mars, na.rm=T))
# SD=NULL
# for (i in 1:length(sizesObserved)){
#   SD[i] <- sd(growthdata$logSize1Mars[growthdata$logSize0Mars==(sizesObserved[i])])
#   }
# SDlm=lm(SD ~ sizesObserved)


#Growth function
Gyx0 <- function (y, x, a) { # Méthode midpoint
  fake_data$Age <- a #Fixe l'age
  fake_data$Size0Mars <- unique(x) #Fixe la taille
  mu <- predict(Growthglm1, fake_data, allow.new.levels = T, residVar=TRUE) #Prédit les log(taille) à t+1 possibles 
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean) #Calcule la moyenne des log(taille)t+1
  M <- matrix(mu2$V1, length(x), length(y), byrow = T)
  usd <- predict(SDlm, data.frame(sizesObserved=x))
  return(dnorm(log(y), mean = M, sd = usd)) #Proba qu'un individu soit de taille y à t+1 sachant la moyenne et la variance
}

Gyx1 <- function(ysup,yinf,x,a){ # Croissance CDF log
  yinf[1] <- -Inf
  ysup[length(ysup)] <- Inf
  
  fake_data <- expand.grid(
  year = annees,
  Pop = populations,
  Size0Mars = unique(x),
  Age = a)
  mu <- exp(predict(Growthglm12, fake_data, allow.new.levels = T)) #Prédit les taille à t+1 possibles 
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean) #Calcule la moyenne des taillet+1
  usd <- sqrt(0.27795)
  usd <- sqrt(exp(-0.8872301-0.4646620*log(unique(x))))

  cdf.sup <- mapply(pnorm, mean = mu2$V1, sd = usd, MoreArgs = list(q=ysup))
  cdf.inf <- mapply(pnorm, mean = mu2$V1, sd = usd, MoreArgs = list(q=yinf))

  return(cdf.sup - cdf.inf)}


Gyx2 <- function(ysup,yinf,x,a){ # Croissance CDF sans log 
  yinf[1] <- -Inf
  ysup[length(ysup)] <- Inf
  
  fake_data <- expand.grid(
  year = annees,
  Pop = populations,
  Size0Mars = unique(x),
  Age = a)
  mu <- predict(Growthglm2, fake_data, allow.new.levels = T) #Prédit les taille à t+1 possibles 
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean) #Calcule la moyenne des taillet+1
  usd <- sqrt(exp(1.0462608+0.5367287*log(unique(x))))

  cdf.sup <- mapply(pnorm, mean = mu2$V1, sd = usd, MoreArgs = list(q=ysup))
  cdf.inf <- mapply(pnorm, mean = mu2$V1, sd = usd, MoreArgs = list(q=yinf))
  # cdf.sup <- mapply(pnorm, q=ysup, MoreArgs = list(mean = mu2$V1, sd = usd))
  # cdf.inf <- mapply(pnorm, q=yinf, MoreArgs = list(mean = mu2$V1, sd = usd))
  return(cdf.sup - cdf.inf)}

#Seedling size density
densSeedl <- function(ysup, yinf) {
  yinf[1] <- -Inf
  ysup[length(ysup)] <- Inf
  mu <- predict(Pltglm1, newdata = fake_data)[, 1]
  shape <- 1 / Pltglm1$phi
  mu <- mean(mu)
  scale <- mu * Pltglm1$phi
  cdf.sup <- pgamma(ysup, shape = shape, scale = scale)
  cdf.inf <- pgamma(yinf, shape = shape, scale = scale)
  return(cdf.sup - cdf.inf)
}

Pop <- populations
year <- annees

Estbli <- function(Pop=Pop, year=annees){
  fake_data <- expand.grid(
  year = year,
  Pop = Pop)
  mu <- mean(predict(Estbglm1, newdata= fake_data))
  # sample(predict(Estbglm1),1)
  return(mu)
}

#Combine fecundity and flowering probability 
fyx02 <- function(x , a, Estbl, Beta = 0) {
  #flowering probability:
  p.flow <- flr1(x, a, Beta)
  #number of capitula per flowering plant
  n.captl <- numbofcap(x, a)
  #survival probability
  if(a==1){p.surv <- sx01(x,1)}
  if(a!=1){p.surv <- sx02(x,a)}
  # p.surv <- ifelse(a==1,sx01(x,a),sx02(x,a))
  # p.surv <- matrix(p.surv, MatrixDim, MatrixDim, byrow = T)
  
  Fyx0 <- p.flow * n.captl * Estbl 
  # * p.surv
  return(Fyx0)
}

fyx0 <- function(y, x , a, Estbl, Beta = 0, intervalle) {
  #flowering probability:
  p.flow <- flr1(x, a, Beta)
  #number of capitula per flowering plant
  n.captl <- numbofcap(x, a)
  #Seedlings Size distribution
  ProporSeedlSize <- densSeedl2(y,intervalle)
  #survival probability
  sx0 <- ifelse(a==1,sx01,sx02)
  p.surv <- sx0(x,a)
  
  Fyx0 <- ifelse((p.flow * n.captl * Estbl * ProporSeedlSize) >= 0,
                 p.flow * n.captl * Estbl * ProporSeedlSize * p.surv,
                 0)
  return(Fyx0)
}
```

```{r}
n.size <- 50
age <- 2
estbl <- RecrRate
Beta <- 0

K.fnc0 <- function(age, n.size, estbl, Beta=0){
  
  minsize <-  0.5
  maxsize <-  25
  maxsize1 <- 15
  h <-  (maxsize - minsize) / n.size
  h1 <-  (maxsize1 - minsize) / n.size
  b <- minsize + c(0:n.size) * h

  #sizes for an individual of age a
  #midpoint
  ymid.a = 0.5 * (b[1:n.size] + b[2:(n.size + 1)])
  #intervals
  yI.a <- matrix(nrow = n.size, ncol = 2)
  for (i in 1:n.size){
    yI.a[i,1] <- b[i]
    yI.a[i,2] <- b[i+1]
  }
  
  b1 = minsize + c(0:n.size) * h1
  #sizes for an individual of age 1
  #midpoint
  ymid.1 = 0.5 * (b1[1:n.size] + b1[2:(n.size + 1)])
  #intervals
  yI.1 <- matrix(nrow = n.size, ncol = 2)
  for (i in 1:n.size){
    yI.1[i,1] <- b1[i]
    yI.1[i,2] <- b1[i+1]
  }
  
  if(age==1){h <- h1
    ymid.a <- ymid.1
    # yI.a <- yI.1
  }
  #The growth kernel
  G <- Gyx2(ysup=yI.a[,2], yinf=yI.a[,1], x=ymid.a, a=age)

  #The survival-growth kernel #remove flowering plants since they died
  sx0 <- ifelse(age==1,sx01,sx02)
  if(age==1){surv <- sx01(ymid.a,1)}
  if(age!=1){surv <- sx02(ymid.a,age)}
  S_flr <- surv*(1-flr0(ymid.a,age,Beta))
  # S_flr <- sx0(ymid.a,age)*(1-flr0(ymid.a,age,Beta))
  Ps <- sweep(G, MARGIN=2, S_flr, '*')
  P <- matrix(Ps, nrow=n.size)
  
  #Fecundity
  
  ProporSeedlSize <- densSeedl(ysup=yI.1[,2],yinf=yI.1[,1])
  feco <- fyx02(x = ymid.a, a = age, Estbl = estbl, Beta = Beta)
  Fec <- sweep(feco, MARGIN=1, ProporSeedlSize, '*')

  IPMk <- P + Fec
  return(list(M=IPMk,Pk=P,Fk=Fec))
    }
```

the super matrix and growth rate
```{r}
super_matrix = function(Beta_test){
  Pk <- matrix(data = NA, nrow = MatrixDim, ncol = MatrixDim)
  Fk <- matrix(data = NA, nrow = MatrixDim, ncol = MatrixDim)
  Mk <- matrix(data = NA, nrow = MatrixDim, ncol = MatrixDim)
  Kernals <- array(data = 0, dim = c(AgeMax, 3, MatrixDim, MatrixDim))
  GlobMatrIPM <- array(0, dim = c((AgeMax * MatrixDim), (AgeMax * MatrixDim)))
  # estbl <- Estbli(Pop,annees)
  
  for (a in (1:(AgeMax - 1))){
    Kls <- K.fnc0(a, MatrixDim, estbl, Beta_test)
    Kernals[a, 1, , ] <- Kls$M
    Kernals[a, 2, , ] <- Kls$Pk
    Kernals[a, 3, , ] <- Kls$Fk
    # print(lambda(Kernals[a, 1, , ]))
    debut <- (a - 1) * MatrixDim + 1
    fin <- debut + (MatrixDim - 1)
    GlobMatrIPM[1:MatrixDim, (debut:fin)] <- Kls$Fk
    GlobMatrIPM[((fin + 1):(fin + MatrixDim)), (debut:fin)] <- Kls$Pk
  }
  
  Kls <- K.fnc0(AgeMax, MatrixDim, estbl, Beta_test)
  Kernals[AgeMax, 1, , ] <- Kls$M
  Kernals[AgeMax, 2, , ] <- Kls$Pk
  Kernals[AgeMax, 3, , ] <- Kls$Fk
  # print(lambda(Kernals[a,1,,]))
  debut <- (AgeMax - 1) * MatrixDim + 1
  fin <- debut + (MatrixDim - 1)
  GlobMatrIPM[1:MatrixDim, (debut:fin)] <- Kls$Fk
  GlobMatrIPM[(debut:fin), (debut:fin)] <- Kls$Pk
  
  return(GlobMatrIPM)
}
```

```{r}
# estbl <- Estbli(Pop,year)
# estbl <- 0.26
MatrixIPM <- super_matrix(0) # growthrate values reported in table 1
print(lambda(MatrixIPM))

M1 <- MatrixIPM[51:100,1:50]
M2 <- MatrixIPM[101:150,51:100]
M3 <- MatrixIPM[151:200,101:150]
M8 <- MatrixIPM[351:400,301:350]

eps <- 1e-4
for (i in 1:50){
  for (j in 1:50){
    if(M1[i,j]<eps){M1[i,j] <- 0}    
    if(M2[i,j]<eps){M2[i,j] <- 0}    
    if(M3[i,j]<eps){M3[i,j] <- 0}
    if(M8[i,j]<eps){M8[i,j] <- 0}

  }
}
image2(M1,cex=0.3)
image2(M2,cex=0.3)
image2(M3,cex=0.3)
image2(M8,cex=0.3)

```

Sensitivity and elasticity analysis
```{r}
K <- MatrixIPM

IPM.eig.sys <- eigen(K)
lambda <- Re(IPM.eig.sys$values[1])
w.z <- Re(IPM.eig.sys$vectors[,1])
v.z1 <- Re(eigen(t(K))$vectors[,1])

minsize <-  0.5
maxsize <-  25
maxsize1 <- 15
h <- (maxsize - minsize) / n.size
h1 <- (maxsize1 - minsize) / n.size

k <- 0
som <- 0
for(i in 1:400){
  k <- ifelse(i %in% 1:50, h, h1)
  som <- som + v.z1[i]*w.z[i]*k
}
# K.sens <- outer(v.z1, w.z, "*")/sum(v.z1 * w.z * h)
K.sens <- outer(v.z1, w.z, "*")/som
Kbis <- K
for (j in 1:400){
  for (i in 1:100){
    Kbis[i,j] <- Kbis[i,j]/h1
  }
  for (i in 101:400){
    Kbis[i,j] <- Kbis[i,j]/h
  }
}
K.elas <- K.sens * Kbis / lambda
K.elas <- K.sens * (K/h) / lambda
```


```{r}
sous_mat <- function(Matrix, n_subclass, class_row, class_col){
  n_size <- dim(Matrix)[1]/n_subclass
  row <- ((class_row-1)*n_size+1):(class_row*n_size)
  col <- ((class_col-1)*n_size+1):(class_col*n_size)
  sm <- Matrix[row,col]
  return(sm)
}

image2(sous_mat(K,8,4,3),cex=0.1)
```


Sensitivity

```{r}
library(IPMpack)
library(viridis)

# Paramètres
n_size <- 50
n_age <- 8
size_vector <- 1:(MatrixDim*n_age)

# Plages de tailles
size_range_age1 <- seq(0.5, 15, length.out = n_size)
size_range_other <- seq(0.5, 25, length.out = n_size)

# Chargement de la matrice de sensibilité
K <- MatrixIPM

K.sens <- IPMpack::sens(K)

# Extraire les sous-matrices de sensibilité pour chaque âge
sensitivity_list <- list()

for (a in 1:n_age) {
  idx <- ((a - 1) * n_size + 1):(a * n_size)
  submat <- K.sens[idx, idx]
  sub_mat <- sous_mat(K.sens,n_age,a,a)
  # submat <- submat / max(submat)  # Normaliser chaque bloc
  sensitivity_list[[a]] <- submat
}

image(size_vector,size_vector,t(K.sens))

filled.contour(
  x = size_vector,
  y = size_vector,
  z = t(K.sens),
  col = gray.colors(100,start=1,end=0),
  plot.title = title(main = "Matrice complète de sensibilité", 
                     xlab = "Taille à t (z)", 
                     ylab = "Taille à t+1 (z')"),
  key.title = title("Sensibilité"),
  plot.axes = {
    axis(1); axis(2)
    contour(size_vector, size_vector, t(K.sens), add = TRUE)
  }
)
# Tracer les sous-matrices avec contours
par(mfrow = c(2, 4), mar = c(4, 4, 2, 1))

for (a in 1:n_age) {
  mat <- sensitivity_list[[a]]
  sizes0 <- if (a == 1) size_range_age1 else size_range_other
  
  filled.contour(
    x = sizes0, y = size_range_other, z = t(mat),
    color.palette = gray.colors,
    plot.title = title(main = paste("Age", a), xlab = "Size(t), x", ylab = "Size(t+1), y'"),
    key.title = title("Sensitivity"),
    plot.axes = {
      axis(1); axis(2)
      contour(sizes0, size_range_other, t(mat), add = TRUE, drawlabels = TRUE)
    }
  )
}
```

Elasticity
```{r}
library(IPMpack)
library(viridis)

# Paramètres
n_size <- 50
n_age <- 8

# Plages de tailles
size_range_age1 <- seq(0.5, 15, length.out = n_size)
size_range_other <- seq(0.5, 25, length.out = n_size)

# Chargement de la matrice de sensibilité
K <- MatrixIPM

K.sens <- IPMpack::sens(K)
K.elas <- IPMpack::elas(K)



# Extraire les sous-matrices de sensibilité pour chaque âge
elasticity_list <- list()

for (a in 2:(n_age-1)) {
  # idx <- ((a - 1) * n_size + 1):(a * n_size)
  # submat <- elasticity_mat[idx, idx]
  submat <- sous_mat(K.elas,n_age,a,a)
  # submat <- submat / max(submat)  # Normaliser chaque bloc
  elasticity_list[[a]] <- submat
}
elasticity_list[[1]] <- sous_mat(K.elas,n_age,1,2)
elasticity_list[[8]] <- sous_mat(K.elas,n_age,8,8)

image(size_vector,size_vector,t(K.elas))

filled.contour(
  x = size_vector,
  y = size_vector,
  z = t(K.elas),
  col = gray.colors(100,start=1,end=0),
  plot.title = title(main = "Matrice complète de elasticité", 
                     xlab = "Taille à t (z)", 
                     ylab = "Taille à t+1 (z')"),
  key.title = title("Elasticité"),
  plot.axes = {
    axis(1); axis(2)
    contour(size_vector, size_vector, t(K.elas), add = TRUE)
  }
)
# Tracer les sous-matrices avec contours
par(mfrow = c(2, 4), mar = c(4, 4, 2, 1))

for (a in 1:n_age) {
  mat <- elasticity_list[[a]]
  sizes0 <- if (a == 1) size_range_age1 else size_range_other
  
  filled.contour(
    x = sizes0, y = size_range_other, z = t(mat),
    color.palette = gray.colors,
    plot.title = title(main = paste("Age", a), xlab = "Size(t), x", ylab = "Size(t+1), y'"),
    key.title = title("Elasticity"),
    plot.axes = {
      axis(1); axis(2)
      contour(sizes0, size_range_other, t(mat), add = TRUE, drawlabels = TRUE)
    }
  )
}
```


```{r}
MatrixDim <- 10
MatrixIPM <- super_matrix(0) 
plot(MatrixIPM[,9])
image2(MatrixIPM,cex=0.3)
```

Stable distribution size by age
```{r}
MatrixDim <- 50
MatrixIPM <- super_matrix(0) 

A <- eigen.analysis(MatrixIPM)
A$lambda1

# AA <- matrix(ncol = 8, nrow = 50)
# for (i in 1:8){
#   AA[,i] <- A$stable.stage[(50*(i-1)+1):(50*i)]
#   AA$age <- i
# }
# AA <- as_tibble(AA)
# names(AA) <- c("age1","age2","age3","age4","age5","age6","age7","age8")

minsize <-  0.5
maxsize <-  25
maxsize1 <- 15
h <-  (maxsize - minsize) / n.size
h1 <-  (maxsize1 - minsize) / n.size
b <- minsize + c(0:n.size) * h
b1 <- minsize + c(0:n.size) * h1
x <- 0.5 * (b[1:n.size] + b[2:(n.size + 1)])
x1 <- 0.5 * (b1[1:n.size] + b1[2:(n.size + 1)])

AA <- tibble(
  Size1 = rep(x1,8),
  Size = rep(x,8),
  density = rep(NA,50*8),
  age = rep(NA,50*8)
)
  
for (i in 1:8){
  AA$density[(50*(i-1)+1):(50*i)] <- A$stable.stage[(50*(i-1)+1):(50*i)]
  AA$age[(50*(i-1)+1):(50*i)]  <- rep(i,50)
  }

AA %>% 
  filter(age!=1) %>% 
  ggplot()+
  geom_line(aes(x=Size,y=density,color=as.factor(age)))+
  # geom_smooth(aes(x=Size,y=density,color=as.factor(age)))+
  theme_bw()
  
AA %>% 
  filter(age==1) %>% 
  ggplot()+
  geom_line(aes(x=Size1,y=density),col="red")+
  theme_bw()

```

```{r}
hist(centauree_data[centauree_data$Age==2,]$Size0Mars,breaks=100)
centauree_data[centauree_data$Age==2,]$Size0Mars

centauree_data %>% 
  select(Size0Mars,Age) %>% 
  # filter(Age==1) %>% 
  ggplot(aes(x = Size0Mars)) +
  geom_histogram(aes(y=..density..),
                  binwidth = 0.5, 
                 boundary = 0.5,  # aligne les barres sur 0.5
                 fill = "grey", 
                 color = "black", 
                 closed = "left") +  # pour inclure la borne gauche
  # geom_line(data = AA %>% filter(age==1),aes(x=Size1,y=density*8),color="red")+
  scale_x_continuous(breaks = seq(0.5, 25, by = 1.5)) +
  theme_minimal()+
  facet_wrap(~Age)
```

```{r}
n <- length(centauree_data$Individu)
centauree_data %>% 
  select(Size0Mars,Age) %>% 
  group_by(Age) %>% 
  mutate(density_obs=length(Size0Mars)/n) %>% 
  ggplot(aes(x=Size0Mars))+
  geom_col(aes(y=density_obs))+
  facet_wrap(~Age)+
  theme_bw()
```


```{r}
AA %>% filter(age!=1) %>% 
  ggplot()+
  geom_line(aes(x=Size,y=density))+
  # geom_smooth(aes(x=Size,y=density))+
  theme_bw()+
  facet_wrap(~age)

AA_normalised %>% 
  filter(age==1) %>% 
  ggplot()+
  geom_line(aes(x=Size,y=density))+
  # geom_smooth(aes(x=Size,y=density))+
  theme_bw()
```


```{r}
obs_lambda <- super_matrix(0) # growthrate values reported in table 1
print(obs_lambda)
print(obs_beta)

mean_size <- mean(IPM_data$Size0Mars[which(IPM_data$Flowering == 1)])
sd_size <- sd(IPM_data$Size0Mars[which(IPM_data$Flowering == 1)])
print(mean_size)
print(sd_size)

mean_age <- mean(IPM_data$Age[which(IPM_data$Flowering == 1)], na.rm = T)
sd_age <- sd(IPM_data$Age[which(IPM_data$Flowering == 1)], na.rm = T)

print(mean_age)
print(sd_age)
```

test de différentes tailles de matrice (effet sur la précision de "l'intégration")
```{r}
lambk <- NULL
library(foreach)
library(doParallel)

cl <- makeCluster(10)
registerDoParallel(cl)

lambk <- foreach (k=seq(2,50,5),.packages=c("splines","spaMM","popbio")) %dopar% {
  MatrixDim <- k
  obs_lambda <- super_matrix(0)
  obs_lambda
}
stopCluster(cl)

lambk <- unlist(lambk)
plot(x = (1:length(lambk))*5, y = lambk, type = "l") ; abline(a=lambk[length(lambk)],b=0,col="red")
```

Changes in the optimal flowering strategy
```{r}
minbeta <- -25-obs_beta
maxbeta <- 5-obs_beta
beta <- seq(minbeta,maxbeta,1)
lam <- list()
for (i in 1:length(beta)){
  lam[i] <- unlist(super_matrix(beta[i]))
}
lam <- unlist(lam)
pos <- order(lam[1:20])
maxibeta <- beta[pos[length(pos)]]
plot(x=beta+obs_beta,y=lam,type = 'line') ; abline(v=obs_beta,col="green4",lty=2) ; abline(v=obs_beta-se_obs_beta,lty=2) ; abline(v=obs_beta+se_obs_beta,lty=2) ; abline(v=maxibeta+obs_beta,col="red") ; abline(h=0.869,lty=2,col="green4"); abline(h=max(lam[1:20]),col="red",lty=3) 
```


Size at flowering using the stable distribution size at flowering
Method Rees and Rose 2002
```{r,}
B <- 0; mu <- NULL; StablSize <- array(0,dim = c(MatrixDim,AgeMax))
minsize <-  0.5
maxsize <-  max(IPM_data$Size0Mars, na.rm=T)
X <- seq(minsize,maxsize,length=MatrixDim)

for (i in 1:AgeMax) {
  sx0 <- ifelse(i == 1, sx01, sx02)
  Kernals <- K.fnc0(i, MatrixDim, RecrRate, B)
  AA <- eigen.analysis(Kernals$M)
  V <- AA$stable.stage
  mm <- lm(log(1/V) ~ X)
  
  V_y <- function(y) {return(exp(-coef(mm)[1]-coef(mm)[2]*y))}
  Flr <- function(y,a) {return(sx0(y,a)*flr0(y,a,B)*V_y(y) ) }
  int_age <- as.numeric(integrate(Flr, minsize, maxsize, i, stop.on.error = F)$value)
  
  W_y <- function(y) {return(Flr(y,i)/int_age)}
  Z_y <- function(y,a) {return(W_y(y)*y)}

  Mu <- integrate(Z_y, minsize, maxsize, i, stop.on.error = F) #Mean size at flowering
  mu[i] <- (Mu$value) #Mean size at flowering
  StablSize[, i] <- 100 * (W_y((X)))
}


S <- rowSums(StablSize)
W <- weightAgeFlrPool/sum(weightAgeFlrPool )
mu_glob <- sum(mu*W) #Predicted Mean size at flowering
mu_glob

observed_mean_value <- mean(centauree_data$Size0Mars[which( centauree_data$Age!="NA" & centauree_data$Flowering==1)])
observed_mean_value
observed_sd_value <- sd(centauree_data$Size0Mars[which( centauree_data$Age!="NA" & centauree_data$Flowering==1)])
observed_sd_value


hist(centauree_data$Size0Mars[which( centauree_data$Age!="NA" & centauree_data$Flowering==1 )],xlim = c(0,30),col="blue4",main = "",xlab = "Size of flowering plants (cm)",  ylab = "Nbr. of flowering individuals",   freq = T ,ylim= c(0, 80),breaks =10);lines(X,S,lwd=2,col="green4")
```




```{r}
barplot(AA$stable.stage, col="green", ylim=c(0,0.05), ylab="Stable stage proportion", xlab="Stage class", main="Teasel")
image2(AA$elasticities, cex=.1, mar=c(0.5,3,4,1) )
image2(AA$sensitivities, cex=.1, mar=c(0.5,3,4,1) )
```


age at flowering
```{r}
#Predicted


#Observed
flower_data <- centauree_data[centauree_data$Flowering==1 & !is.na(centauree_data$Flowering),]
flower_data %>% 
  group_by(Pop) %>% 
  mutate(mean.age = mean(Age,na.rm=TRUE)) %>% 
  ggplot(aes(x=Pop, y=Age)) +
  geom_boxplot(fill="grey")+
  geom_point(aes(y=mean.age),color= "pink3")+
  theme_bw()
```


```{r}
growthdata %>% 
  group_by(Size0Mars) %>% 
  mutate(observed_sd = sd(Size1Mars),
         predicted_sd = sqrt(exp(1.0462608+0.5367287*log(Size0Mars)))) %>% 
  ggplot(aes(x=Size0Mars))+
  geom_smooth(aes(y = observed_sd),color="red")+
  geom_line(aes(y = predicted_sd))+
  theme_bw()+
  labs(y = "Residual Variance",
       x = "Size",
       title = "Comparaison entre la variance observée (rouge) 
       et la variance prédite (noire)")
```

