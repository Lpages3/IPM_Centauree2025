---
  title: "Integrated Population Model"
author: "Eric Imbert & Loïc Pages"
date: "`r Sys.Date()`"
output:
  html_document:
  df_print: paged
word_document: default
pdf_document: default
---
  
# Initialisation
```{r}
rm(list=ls())
library(knitr)
library(spaMM)
library(tidyverse)
library(popbio)
library(splines)

setwd("/media/loic/Commun/0Travail/Stage 2025 ISEM/Models/IPM")

centauree_data <- read.csv("donnesIPM_short.csv")
centauree_data_complet <- read.csv("donnesIPM.csv")

MatrixDim <- 50
RecrRate <- 0.407 #recruitment rate

#Forcer l'age maximal à 8
AgeMax <- 8
centauree_data$age1 <- ifelse(centauree_data$Stage1=="V",centauree_data$age0+1,NA)
centauree_data$age0[centauree_data$age0 > AgeMax] <- AgeMax
centauree_data$age1[centauree_data$age1 > AgeMax] <- AgeMax

spaMM.options(separation_max=70)
```

Age of flowering plants - will be used later to compute optimal growth rate
```{r}
weightAgeFlrPool=NULL
for ( a in 1:AgeMax ) {
  weightAgeFlrPool[a]= nrow(centauree_data[which(centauree_data$age0==a & centauree_data$Flowering0==1),])
}
```

Seedling size distribution
```{r}
plantule_data <- centauree_data_complet[centauree_data_complet$age0==1,] %>% 
  filter(!is.na(age0)) %>% 
  filter(Size0Mars!=0)

n_plt <- length(plantule_data$Nrw)

sizeSeedl <- unique(plantule_data$Size0Mars[order(plantule_data$Size0Mars)])

Width <-NULL 
Den <- NULL 

for (i in 1:length(sizeSeedl)){
  # Number of observations for each size
  Width[i] <- length(unique(plantule_data$Nrw[plantule_data$Size0Mars==sizeSeedl[i]]))
  # Frequency of each size
  Den[i] <- Width[i]/n_plt
}
Width
Den
dens <- rep(Den,Width)

gg1=lm(log(1/dens)~rep(sizeSeedl,Width))

densSeedl2=function(y,intervalle){   
  miny=min(y)
  maxy=max(y)
  SeedlgSize=exp(log(coef(gg1)[2])-y*coef(gg1)[2])/(exp(-coef(gg1)[2]*(miny-intervalle/2))-exp(-coef(gg1)[2]*(maxy+intervalle/2)))
  return(SeedlgSize)
}
```

## Models

Load the false data set which contains the predicted responses for survival probability, flowering probability, number of capitules (fecondity) and growth. There is a value of each of these response for each combination of size, age, population and year.
```{r}
## Creation of fake data
AgeMax <- 8
year <- 1995:2022
Pop <- c("Po","Au","Pe","E1","E2","Cr")
taille_range <- seq(0.5, 25, by = 0.5) 
age_range <- 1:AgeMax
# 
# fake_data <- expand.grid(
#   year = annees,
#   Pop = populations,
#   Size0Mars = NA,
#   age0 = NA)
# 

# Pop=gl(6,length(year),labels = Pop)
# rer$Index=1:(length(year)*6)
rer=data.frame(year)
fake_data=do.call("rbind", replicate(MatrixDim, rer, simplify = FALSE))
# fake_data=fake_data[order(fake_data$Index),]
fake_data$Size0Mars=NA
fake_data$age0=NA
fake_data$Pop <- NA

rm(rer, Pop, year)

load("ModelsAIC")

growthdata <- centauree_data[!is.na(centauree_data$Size1Mars), ]
growthdata <- growthdata[growthdata$Size1Mars != 0, ]
growthdata <- growthdata[!is.na(growthdata$age0),]
```

Creation of the functions for the kernels. 
```{r}
#Fecundity
numbofcap <- function(x, a) {
  fake_data$age0 <- a
  fake_data$Size0Mars <- unique(x)
  mu <- exp(predict(Cptlglm1, fake_data))
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean)
  nbcap <- ifelse(mu2$V1>=0,mu2$V1,0)
  return(matrix(nbcap, length(x), length(x), byrow = T))
}


#Survival Probability for age 1
sx01 <- function(x,a,Pop) {
  fake_data$age0 <- a
  fake_data$Size0Mars <- x
  fake_data$Pop <- Pop
  mu <- predict(Survglm11, fake_data, allow.new.levels = T)
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean)
  return(mu2$V1)
}

#Survival Probability for age > 1
sx02 <- function(x,a,Pop) {
  fake_data$age0 <- a
  fake_data$Size0Mars <- x
  fake_data$Pop <- Pop
  mu <- predict(Survglm12, fake_data, allow.new.levels = T)
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean)
  return(mu2$V1)
}


#Flowering Probability
#Beta = will be used to modify the intercept of the flowering function
#obs_beta = observed value
#extract Beta0
load("obs_beta")
load("se_obs_beta")


#Flowering function for The survival-growth kernel
flr0 <- function(x, a, Beta,Pop) {
  fake_data$age0 <- a
  fake_data$Size0Mars <- unique(x)
  fake_data$Pop <- Pop
  mu <- plogis(predict(Flowglm1, newdata = fake_data, allow.new.levels = T, type = "link") + Beta)
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean)
  return(mu2$V1)
}

#Flowering function for fecundity fyx0 - same function the difference is in the format of the output
flr1 <- function(x, a, Beta,Pop) {
  fake_data$age0 <- a
  fake_data$Size0Mars <- unique(x)
  fake_data$Pop <- Pop
  mu <- plogis(predict(Flowglm1, fake_data, allow.new.levels = T, type = "link") + Beta)
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean)
  return(matrix(mu2$V1, MatrixDim, MatrixDim, byrow = T))
}

sizesObserved=sort(unique(centauree_data$Size0Mars, na.rm=T))
SD=NULL
for (i in 1:length(sizesObserved)){
  SD[i]=sd(centauree_data$Size1Mars[which(centauree_data$Size1Mars !=0 & centauree_data$Size0Mars==(sizesObserved[i]))])}
SD=SD[which(SD!=0)]
sizesObserved=sizesObserved[which(SD!=0)]
SDlm=lm(SD ~ sizesObserved)

#Growth function
Gyx0 <- function (y, x, a,Pop) { #Méthode midpoint
  fake_data$age0 <- a #Fixe l'age
  fake_data$Size0Mars <- unique(x) #Fixe la taille
  fake_data$Pop <- Pop #Fixe la Pop
  mu <- predict(Growthglm1, fake_data, allow.new.levels = T, residVar=TRUE) #Prédit les log(taille) à t+1 possibles 
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean) #Calcule la moyenne des log(taille)t+1
  M <- matrix(mu2$V1, MatrixDim, MatrixDim, byrow = T)
  Sdev <- mean(residVar(Growthglm1))
  return(dnorm(y, mean = exp(M), sd = exp(Sdev))) #Proba qu'un individu soit de taille y à t+1 sachant la moyenne et la variance
}
# summary(Gyx0(y,x,a))

annees <- 1995:2022
populations <- c("Po","Au","Pe","E1","E2","Cr")

Gyx1 <- function(ysup,yinf,x,a,Pop){ # Croissance CDF log
  yinf[1] <- -Inf
  ysup[length(ysup)] <- Inf
  
  fake_data$age0 <- a #Fixe l'age
  fake_data$Size0Mars <- unique(x) #Fixe la taille
  fake_data$Pop <- Pop
  mu <- exp(predict(Growthglm12, fake_data, allow.new.levels = T)) #Prédit les taille à t+1 possibles 
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean) #Calcule la moyenne des taillet+1
  usd <- sqrt(0.27795)
  # usd <- sqrt(exp(-0.8872301-0.4646620*log(unique(x))))

  cdf.sup <- mapply(pnorm, mean = mu2$V1, sd = usd, MoreArgs = list(q=ysup))
  cdf.inf <- mapply(pnorm, mean = mu2$V1, sd = usd, MoreArgs = list(q=yinf))
  return(cdf.sup - cdf.inf)
}

Gyx2 <- function(ysup,yinf,x,a,Pop){ # Croissance CDF sans log
  yinf[1] <- -Inf
  ysup[length(ysup)] <- Inf
  
  fake_data$age0 <- a #Fixe l'age
  fake_data$Size0Mars <- unique(x) #Fixe la taille
  fake_data$Pop <- Pop
  mu <- predict(Growthglm2, fake_data, allow.new.levels = T) #Prédit les taille à t+1 possibles 
  mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean) #Calcule la moyenne des taillet+1
  usd <- sqrt(exp(1.0462608+0.5367287*log(unique(x))))

  cdf.sup <- mapply(pnorm, mean = mu2$V1, sd = usd, MoreArgs = list(q=ysup))
  cdf.inf <- mapply(pnorm, mean = mu2$V1, sd = usd, MoreArgs = list(q=yinf))
  return(cdf.sup - cdf.inf)
}

densSeedl <- function(ysup, yinf,Pop) {
  yinf[1] <- -Inf
  ysup[length(ysup)] <- Inf
  fake_data$Pop <- Pop
  mu <- predict(Pltglm1, newdata = fake_data)[, 1]
  shape <- 1 / Pltglm1$phi
  mu <- mean(mu)
  scale <- mu * Pltglm1$phi
  cdf.sup <- pgamma(ysup, shape = shape, scale = scale)
  cdf.inf <- pgamma(yinf, shape = shape, scale = scale)
  return(cdf.sup - cdf.inf)
}

#Combine fecundity and flowering probability 
fyx0 <- function(x , a, Estbl, Beta = 0, Pop) {
  #flowering probability:
  p.flow <- flr1(x, a, Beta,Pop)
  #number of capitula per flowering plant
  n.captl <- numbofcap(x, a)
  #survival probability
  sx0 <- ifelse(a==1,sx01,sx02)
  p.surv <- sx0(x,a,Pop)
  
  feco <- p.flow * n.captl * Estbl * p.surv
  return(feco)
}
```

```{r}
n.size <- 50

K.fnc0 <- function(age, n.size, estbl, Beta=0, Pop){
  
  minsize <-  0.5
  maxsize <-  25
  maxsize1 <- 15
  h <-  (maxsize - minsize) / n.size
  h1 <-  (maxsize1 - minsize) / n.size
  b = minsize + c(0:n.size) * h

  #sizes for an individual of age a
  #midpoint
  ymid.a = 0.5 * (b[1:n.size] + b[2:(n.size + 1)])
  #intervals
  yI.a <- matrix(nrow = n.size, ncol = 2)
  for (i in 1:n.size){
    yI.a[i,1] <- b[i]
    yI.a[i,2] <- b[i+1]
  }
  
  b1 = minsize + c(0:n.size) * h1
  #sizes for an individual of age 1
  #midpoint
  ymid.1 = 0.5 * (b1[1:n.size] + b1[2:(n.size + 1)])
  #intervals
  yI.1 <- matrix(nrow = n.size, ncol = 2)
  for (i in 1:n.size){
    yI.1[i,1] <- b1[i]
    yI.1[i,2] <- b1[i+1]
  }
  
  if(age==1){ymid.a <- ymid.1 ; yI.a <- yI.1; h <- h1}
  
  #The growth kernel
  G <- Gyx2(ysup=yI.a[,2], yinf=yI.a[,1], x=ymid.a, a=age, Pop=Pop)

    #The survival-growth kernel #remove flowering plants since they died
  sx0 <- ifelse(age==1,sx01,sx02)
  S_flr <- sx0(ymid.a,age, Pop=Pop)*(1-flr0(ymid.a,age,Beta, Pop=Pop))
  Ps <- sweep(G, MARGIN=2, S_flr, '*')
  P <- matrix(Ps, nrow=n.size)
  
  #Fecundity
  
  ProporSeedlSize <- densSeedl(ysup=yI.1[,2],yinf=yI.1[,1], Pop=Pop)
  feco <- fyx0(x = ymid.a, a = age, Estbl = estbl, Beta = Beta, Pop=Pop)
  Fec <- sweep(feco, MARGIN=1, ProporSeedlSize, '*')

  IPMk <- P + Fec
  return(list(M=IPMk,Pk=P,Fk=Fec))
}
```

  
  the super matrix and growth rate
```{r}
super_matrix = function(Beta_test,Pop){
  Pk <- matrix(data = NA, nrow = MatrixDim, ncol = MatrixDim)
  Fk <- matrix(data = NA, nrow = MatrixDim, ncol = MatrixDim)
  Mk <- matrix(data = NA, nrow = MatrixDim, ncol = MatrixDim)
  Kernals <- array(data = 0, dim = c(AgeMax, 3, MatrixDim, MatrixDim))
  GlobMatrIPM <- array(0, dim = c((AgeMax * MatrixDim), (AgeMax * MatrixDim)))
  
  for (a in (1:(AgeMax - 1))){
    Kls <- K.fnc0(a, MatrixDim, RecrRate, Beta_test, Pop)
    Kernals[a, 1, , ] <- Kls$M
    Kernals[a, 2, , ] <- Kls$Pk
    Kernals[a, 3, , ] <- Kls$Fk
    # print(lambda(Kernals[a, 1, , ]))
    debut <- (a - 1) * MatrixDim + 1
    fin <- debut + (MatrixDim - 1)
    GlobMatrIPM[1:MatrixDim, (debut:fin)] <- Kls$Fk
    GlobMatrIPM[((fin + 1):(fin + MatrixDim)), (debut:fin)] <- Kls$Pk
  }
  
  Kls <- K.fnc0(AgeMax, MatrixDim, RecrRate, Beta_test, Pop)
  Kernals[AgeMax, 1, , ] <- Kls$M
  Kernals[AgeMax, 2, , ] <- Kls$Pk
  Kernals[AgeMax, 3, , ] <- Kls$Fk
  # print(lambda(Kernals[a,1,,]))
  debut <- (AgeMax - 1) * MatrixDim + 1
  fin <- debut + (MatrixDim - 1)
  GlobMatrIPM[1:MatrixDim, (debut:fin)] <- Kls$Fk
  GlobMatrIPM[(debut:fin), (debut:fin)] <- Kls$Pk
  
  return(lambda(GlobMatrIPM))
}
```


```{r}
Pop <- c("Po","Au","Pe","E1","E2","Cr")
lam <- NULL
for(i in 1:6){
obs_lambda <- super_matrix(0,Pop[i]) # growthrate values reported in table 1
print(obs_lambda)
lam[i] <- obs_lambda}
mean(lam)
names(lam) <- Pop
print(lam)

print(obs_beta)

mean_size <- mean(centauree_data_complet$Size0Mars[which(centauree_data_complet$Flowering0 == 1)])
sd_size <- sd(centauree_data_complet$Size0Mars[which(centauree_data_complet$Flowering0 == 1)])
print(mean_size)
print(sd_size)

mean_age <- mean(centauree_data_complet$age0[which(centauree_data_complet$Flowering0 == 1)], na.rm = T)
sd_age <- sd(centauree_data_complet$age0[which(centauree_data_complet$Flowering0 == 1)], na.rm = T)

print(mean_age)
print(sd_age)
```

Changes in the optimal flowering strategy by population
```{r}
lam <- matrix(nrow=length(beta),ncol=6)
obs_beta <- NULL
se_obs_beta <- NULL
for (j in 1:6) {
  Flowglm1 <- fitme(Flowering0 ~  1 + poly(Size0Mars,3) + poly(age0,2),
                   family=binomial,
                  data=centauree_data[centauree_data$Pop==Pop[j],], method="PQL/L")
  obs_beta[j] <- as.numeric(Flowglm1$fixef[1])
  se_obs_beta[j] <- as.numeric(sqrt(diag(vcov(Flowglm1)))[1])
  minbeta <- -25-obs_beta[j]
  maxbeta <- 5-obs_beta[j]
  beta <- seq(minbeta,maxbeta,1)
  for (i in 1:length(beta)) {
    lam[i, j] <- unlist(super_matrix(beta[i], Pop = Pop[j]))
  }
}

beta <- beta+obs_beta[6]

for(j in 1:6){
  obs <- obs_beta[j]
  se <- se_obs_beta[j]
  posmax <- order(lam[,j])[length(lam[,j])]
  maxlambda <- max(lam[posmax,j])
  optimalbeta <- beta[posmax]
  
  plot(x = beta, y = lam[,j], type = 'l',ylim = c(0.3,1)) ; abline(v=obs,col="green4",lty=2,lwd=1.5) ; abline(v=obs-se,lty=2,lwd=0.5) ; abline(v=obs+se,lty=2,lwd=0.5) ; abline(v=optimalbeta,col="red") ; abline(h=max(lam[,j]),col="red",lty=3) ; title(Pop[j])
  print(optimalbeta)
  print(obs)
  print(maxlambda)
}
```


Size at flowering using the stable distribution size at flowering
Method Rees and Rose 2002

```{r,}
B <- 0; mu <- NULL; StablSize <- array(0,dim = c(MatrixDim,AgeMax))
minsize <-  0.5
maxsize <-  max(centauree_data_complet$Size0Mars, na.rm=T)
X <- seq(minsize,maxsize,length=MatrixDim)

for (i in 1:AgeMax) {
  print(i)
  sx0 <- ifelse(i == 1, sx01, sx02)
  Kernals <- K.fnc0(i, MatrixDim, RecrRate, B)
  AA <- eigen.analysis(Kernals$M)
  V <- AA$stable.stage
  mm <- lm(log(1/V) ~ X)
  
  V_y <- function(y) {return(exp(-coef(mm)[1]-coef(mm)[2]*y))}
  Flr <- function(y,a) {return(sx0(y,a)*flr0(y,a,B)*V_y(y) ) }
  int_age <- as.numeric(integrate(Flr, minsize, maxsize, i, stop.on.error = F)$value)
  
  W_y <- function(y) {return(Flr(y,i)/int_age)}
  Z_y <- function(y,a) {return(W_y(y)*y)}
  
  Mu <- integrate(Z_y, minsize, maxsize, i, stop.on.error = F) #Mean size at flowering
  mu[i] <- (Mu$value) #Mean size at flowering
  StablSize[, i] <- 100 * (W_y((X)))
}


S <- rowSums(StablSize)
W <- weightAgeFlrPool/sum(weightAgeFlrPool )
mu_glob <- sum(mu*W) #Predicted Mean size at flowering
mu_glob

observed_mean_value <- mean(centauree_data$Size0Mars[which( centauree_data$age0!="NA" & centauree_data$Flowering0==1)])
observed_mean_value
observed_sd_value <- sd(centauree_data$Size0Mars[which( centauree_data$age0!="NA" & centauree_data$Flowering0==1)])
observed_sd_value


hist(centauree_data$Size0Mars[which( centauree_data$age0!="NA" & centauree_data$Flowering0==1 )],xlim = c(0,30),col="blue4",main = "",xlab = "Size of flowering plants (cm)",  ylab = "Nbr. of flowering individuals",   freq = T ,ylim= c(0, 80),breaks =10);lines(X,S,lwd=2,col="green4")
```