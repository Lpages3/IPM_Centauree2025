resid.model=  ~ log(Size0Mars), data=GrowData)
#SD function
sizesObserved=sort(unique(Datashort$Size0Mars, na.rm=T))
SD=NULL
for (i in 1:length(sizesObserved))
{SD[i]=sd(Datashort$Size1Mars[which(Datashort$Size1Mars !=0 & Datashort$Size0Mars==(sizesObserved[i]))])}
SD=SD[which(SD!=0)]
sizesObserved=sizesObserved[which(SD!=0)]
SDlm=lm(SD ~ sizesObserved)
Gyx0 <- function (y,x,a) {
fake$age0=a
fake$Size0Mars=unique(x)
fake$s2=fake$Size0Mars^2
sortie <- predict(GrowthGlm,fake,re.form=~ (s2|year)+ (1|year)+ (1|Pop), allow.new.levels=T)
sortie2=aggregate(sortie,list(fake$Size0Mars),mean)
M<-matrix(sortie2$V1,MatrixDim,MatrixDim, byrow = T)
Sdev <- predict(SDlm, data.frame(sizesObserved=x))
return(dnorm(y,mean=M,sd=Sdev))
}
#Combine fecundity and flowering probability
fyx0 <- function(y, x ,a, Estbl, Beta, intervalle) {
#flowering probability:
p.flow <-flr1(x,a, Beta)
#number of capitula per flowering plant
n.captl <-numbofcap(x,a)
#Seedlings Size distribution
ProporSeedlSize=densSeedl(y, intervalle)
Fyx0=ifelse((p.flow*n.captl*Estbl*ProporSeedlSize) >=0,p.flow*n.captl*Estbl*ProporSeedlSize,0)
return(Fyx0)
}
# Compute kernel
K.fnc0<-function(age,n.size,estbl, Beta) {
# midpoints for an individual of age a
minsize = max(0.5,min(Datashort$Size0Mars[Datashort$age0==age], na.rm=T)-0.5)
maxsize = 0.5+max(Datashort$Size0Mars[Datashort$age0==age], na.rm=T)
h = (maxsize-minsize)/n.size
b = minsize+c(0:n.size)*h
y.a = 0.5*(b[1:n.size]+b[2:(n.size+1)])
# midpoints for an individual of age a+1 (a1)
if (age != AgeMax) {
minsize = max(0.5,min(Datashort$Size0Mars[Datashort$age0==(age+1)], na.rm=T)-0.5)
maxsize = 0.5+max(Datashort$Size0Mars[Datashort$age0==(age+1)], na.rm=T)
ha1 = (maxsize-minsize)/n.size
b = minsize+c(0:n.size)*ha1
y.a1 = 0.5*(b[1:n.size]+b[2:(n.size+1)])
} else {
minsize = max(0.5,min(Datashort$Size0Mars[Datashort$age0==AgeMax], na.rm=T)-0.5)
maxsize = 0.5+max(Datashort$Size0Mars[Datashort$age0==AgeMax], na.rm=T)
ha1 = (maxsize-minsize)/n.size
b = minsize+c(0:n.size)*ha1
y.a1 = 0.5*(b[1:n.size]+b[2:(n.size+1)])
}
# midpoints for an individual of age 1
minsize = max(0.5,min(Dataglob$Size0Mars[Dataglob$age0==1], na.rm=T)-0.5)
maxsize = 0.5+max(Dataglob$Size0Mars[Dataglob$age0==1], na.rm=T)
h1 = (maxsize-minsize)/n.size
b = minsize+c(0:n.size)*h1
y.1 = 0.5*(b[1:n.size]+b[2:(n.size+1)])
#The growth kernel
G <- ha1*outer(y.a1, y.a, Gyx0, a=age)
####the following to make G sum to 1.0 in the event that there is some 'eviction' of individuals
for(i in 1:(n.size/2)) G[1,i]<-G[1,i]+1-sum(G[,i])
for(i in (n.size/2+1):n.size) G[n.size,i]<-G[n.size,i]+1-sum(G[,i])
#The survival-growth kernel #remove  flowering plants since they died
S_flr <- sx0(y.a,age)*(1-flr0(y.a,age, Beta))
Ps <- sweep(G, MARGIN=2, S_flr, '*')
P <- matrix(Ps, nrow=n.size)
#Fecundity
Fec <- h1*outer(y.1, y.a, fyx0 , a=age, Estbl=estbl, Beta=Beta, intervalle=h1)*sx0(y.1,1)
IPMk=P+Fec
return(list(M=IPMk,Pk=P,Fk=Fec))
}
super_matrix=function(Beta_test)
{
Pk=matrix(data=NA, nrow=MatrixDim, ncol=MatrixDim)
Fk=matrix(data=NA, nrow=MatrixDim, ncol=MatrixDim)
Mk=matrix(data=NA, nrow=MatrixDim, ncol=MatrixDim)
Kernals=array(data=0, dim=c(AgeMax,3,MatrixDim,MatrixDim))
GlobMatrIPM=array(0,dim=c((AgeMax*MatrixDim),(AgeMax*MatrixDim)))
for (a in (1:(AgeMax-1)))
{
Kls=K.fnc0(a,MatrixDim,RecrRate, Beta_test)
Kernals[a,1,,]=Kls$M
Kernals[a,2,,]=Kls$Pk
Kernals[a,3,,]=Kls$Fk
#print(lambda(Kernals[a,1,,]))
debut=(a-1)*MatrixDim+1
fin=debut+(MatrixDim-1)
GlobMatrIPM[1:MatrixDim,(debut:fin)]=Kls$Fk
GlobMatrIPM[((fin+1):(fin+MatrixDim)),(debut:fin)]=Kls$Pk
}
Kls=K.fnc0(AgeMax,MatrixDim,RecrRate, Beta_test)
Kernals[AgeMax,1,,]=Kls$M
Kernals[AgeMax,2,,]=Kls$Pk
Kernals[AgeMax,3,,]=Kls$Fk
#print(lambda(Kernals[a,1,,]))
debut=(AgeMax-1)*MatrixDim+1
fin=debut+(MatrixDim-1)
GlobMatrIPM[1:MatrixDim,(debut:fin)]=Kls$Fk
GlobMatrIPM[(debut:fin),(debut:fin)]=Kls$Pk
return(lambda(GlobMatrIPM))
}
obs_lambda=super_matrix(0) # growthrate values reported in table 1
print(obs_lambda)
print(obs_beta)
mean_size=mean(Dataglob$Size0Mars[which(Dataglob$Flowering0==1)])
sd_size=sd(Dataglob$Size0Mars[which(Dataglob$Flowering0==1)])
print(mean_size)
print(sd_size)
mean_age=mean(Dataglob$age0[which(Dataglob$Flowering0==1)], na.rm=T)
sd_age=sd(Dataglob$age0[which(Dataglob$Flowering0==1)], na.rm=T)
print(mean_age)
print(sd_age)
rm(list=ls())
library(knitr)
library(spaMM)
library(tidyverse)
library(popbio)
setwd("/media/loic/Commun/0Travail/Stage 2025 ISEM/Models/IPM")
centauree_data <- read.csv("donnesIPM_short.csv")
centauree_data_complet <- read.csv("donnesIPM.csv")
MatrixDim <- 50
RecrRate <- 0.407 #recruitment rate
#Forcer l'age maximal à 8
AgeMax <- 8
centauree_data$age1 <- ifelse(centauree_data$Stage1=="V",centauree_data$age0+1,NA)
centauree_data$age0[centauree_data$age0 > AgeMax] <- AgeMax
centauree_data$age1[centauree_data$age1 > AgeMax] <- AgeMax
spaMM.options(separation_max=70)
weightAgeFlrPool=NULL
for ( a in 1:AgeMax ) {
weightAgeFlrPool[a]= nrow(centauree_data[which(centauree_data$age0==a & centauree_data$Flowering0==1),])
}
plantule_data <- centauree_data_complet[centauree_data_complet$age0==1,] %>%
filter(!is.na(age0)) %>%
filter(Size0Mars!=0)
n_plt <- length(plantule_data$Nrw)
sizeSeedl <- unique(plantule_data$Size0Mars[order(plantule_data$Size0Mars)])
Width <-NULL
Den <- NULL
for (i in 1:length(sizeSeedl)){
# Number of observations for each size
Width[i] <- length(unique(plantule_data$Nrw[plantule_data$Size0Mars==sizeSeedl[i]]))
# Frequency of each size
Den[i] <- Width[i]/n_plt
}
Width
Den
dens <- rep(Den,Width)
gg1=lm(log(1/dens)~rep(sizeSeedl,Width))
densSeedl=function(y,intervalle){
miny=min(y)
maxy=max(y)
SeedlgSize=exp(log(coef(gg1)[2])-y*coef(gg1)[2])/(exp(-coef(gg1)[2]*(miny-intervalle/2))-exp(-coef(gg1)[2]*(maxy+intervalle/2)))
return(SeedlgSize)
}
## Creation of fake data
AgeMax <- 8
year <- 1995:2022
Pop <- c("Po","Au","Pe","E1","E2","Cr")
taille_range <- seq(0.5, 25, by = 0.5)
age_range <- 1:AgeMax
#
# fake_data <- expand.grid(
#   year = annees,
#   Pop = populations,
#   Size0Mars = NA,
#   age0 = NA)
#
Pop=gl(6,length(year),labels = Pop)
rer=data.frame(Pop,year)
rer$Index=1:(length(year)*6)
fake_data=do.call("rbind", replicate(MatrixDim, rer, simplify = FALSE))
fake_data=fake_data[order(fake_data$Index),]
fake_data$Size0Mars=NA
fake_data$age0=NA
rm(rer, Pop, year)
load("Models")
#Fecundity
numbofcap <- function(x, a) {
fake_data$age0 <- a
fake_data$Size0Mars <- unique(x)
sortie <- predict(Cptlglm1, fake_data)
sortie2 <- aggregate(sortie, list(fake_data$Size0Mars), mean)
return(matrix(sortie2$V1, MatrixDim, MatrixDim, byrow = T))
}
#Survival Probability
sx0 <- function(x, a) {
fake_data$age0 <- a
fake_data$Size0Mars <- x
sortie <- predict(Survglm1, fake_data, allow.new.levels = T)
sortie2 <- aggregate(sortie, list(fake_data$Size0Mars), mean)
return(sortie2$V1)
}
#Flowering Probability
#Beta = will be used to modify the intercept of the flowering function
#obs_beta = observed value
#extract Beta0
load("obs_beta")
load("se_obs_beta")
#Flowering function for The survival-growth kernel
flr0 <- function(x, a, Beta) {
fake_data$age0 <- a
fake_data$Size0Mars <- unique(x)
sortie <- plogis(predict(Flowglm1, fake_data, allow.new.levels = T, type = "link") + Beta)
sortie2 <- aggregate(sortie, list(fake_data$Size0Mars), mean)
return(sortie2$V1)
}
#Flowering function for fecundity fyx0 - same function the difference is in the format of the output
flr1 <- function(x, a, Beta) {
fake_data$age0 <- a
fake_data$Size0Mars <- unique(x)
sortie <- plogis(predict(Flowglm1, fake_data, allow.new.levels = T, type = "link") + Beta)
sortie2 <- aggregate(sortie, list(fake_data$Size0Mars), mean)
return(matrix(sortie2$V1, MatrixDim, MatrixDim, byrow = T))
}
#Growth function
Gyx0 <- function (y, x, a) {
fake_data$age0 <- a
fake_data$Size0Mars <- unique(x)
sortie <- exp(predict(Growthglm1, fake_data, allow.new.levels = T))
sortie2 <- aggregate(sortie, list(fake_data$Size0Mars), mean)
M <- matrix(sortie2$V1, MatrixDim, MatrixDim, byrow = T)
SD <- sd(sortie)
return(dnorm(y, mean = M, sd = SD))
}
#Combine fecundity and flowering probability
fyx0 <- function(y, x , a, Estbl, Beta = 0, intervalle) {
#flowering probability:
p.flow <- flr1(x, a, Beta)
#number of capitula per flowering plant
n.captl <- numbofcap(x, a)
#Seedlings Size distribution
ProporSeedlSize <- densSeedl(y, intervalle)
Fyx0 <- ifelse((p.flow * n.captl * Estbl * ProporSeedlSize) >= 0,
p.flow * n.captl * Estbl * ProporSeedlSize,
0)
return(Fyx0)
}
# Compute kernel
K.fnc0 <- function(age, n.size, estbl, Beta=0) {
# midpoints for an individual of age a
minsize = max(0.5,min(centauree_data$Size0Mars[centauree_data$age0==age], na.rm=T)-0.5)
maxsize = 0.5+max(centauree_data$Size0Mars[centauree_data$age0==age], na.rm=T)
h = (maxsize - minsize) / n.size
b = minsize + c(0:n.size) * h
y.a = 0.5 * (b[1:n.size] + b[2:(n.size + 1)])
# midpoints for an individual of age a+1 (a1)
if (age != AgeMax) {
minsize = max(0.5,min(centauree_data$Size0Mars[centauree_data$age0==(age+1)], na.rm=T)-0.5)
maxsize = 0.5+max(centauree_data$Size0Mars[centauree_data$age0==(age+1)], na.rm=T)
ha1 = (maxsize - minsize) / n.size
b = minsize + c(0:n.size) * ha1
y.a1 = 0.5 * (b[1:n.size] + b[2:(n.size + 1)])
} else {
minsize = max(0.5,min(centauree_data$Size0Mars[centauree_data$age0==AgeMax], na.rm=T)-0.5)
maxsize = 0.5+max(centauree_data$Size0Mars[centauree_data$age0==AgeMax], na.rm=T)
ha1 = (maxsize - minsize) / n.size
b = minsize + c(0:n.size) * ha1
y.a1 = 0.5 * (b[1:n.size] + b[2:(n.size + 1)])
}
# midpoints for an individual of age 1
minsize = max(0.5,min(centauree_data_complet$Size0Mars[centauree_data_complet$age0==1], na.rm=T) - 0.5)
maxsize = 0.5 + max(centauree_data_complet$Size0Mars[centauree_data_complet$age0 == 1], na.rm = T)
h1 = (maxsize - minsize) / n.size
b = minsize + c(0:n.size) * h1
y.1 = 0.5 * (b[1:n.size] + b[2:(n.size + 1)])
#The growth kernel
G <- ha1*outer(y.a1, y.a, Gyx0, a=age)
####the following to make G sum to 1.0 in the event that there is some 'eviction' of individuals
for(i in 1:(n.size/2)) G[1,i]<-G[1,i]+1-sum(G[,i])
for(i in (n.size/2+1):n.size) G[n.size,i]<-G[n.size,i]+1-sum(G[,i])
#The survival-growth kernel #remove  flowering plants since they died
S_flr <- sx0(y.a,age)*(1-flr0(y.a,age, Beta))
Ps <- sweep(G, MARGIN=2, S_flr, '*')
P <- matrix(Ps, nrow=n.size)
#Fecundity
Fec <- h1*outer(y.1, y.a, fyx0 , a=age, Estbl=estbl, Beta=Beta, intervalle=h1)*sx0(y.1,1)
IPMk=P+Fec
return(list(M=IPMk,Pk=P,Fk=Fec))
}
super_matrix=function(Beta_test)
{
Pk=matrix(data=NA, nrow=MatrixDim, ncol=MatrixDim)
Fk=matrix(data=NA, nrow=MatrixDim, ncol=MatrixDim)
Mk=matrix(data=NA, nrow=MatrixDim, ncol=MatrixDim)
Kernals=array(data=0, dim=c(AgeMax,3,MatrixDim,MatrixDim))
GlobMatrIPM=array(0,dim=c((AgeMax*MatrixDim),(AgeMax*MatrixDim)))
for (a in (1:(AgeMax-1)))
{
Kls=K.fnc0(a,MatrixDim,RecrRate, Beta_test)
Kernals[a,1,,]=Kls$M
Kernals[a,2,,]=Kls$Pk
Kernals[a,3,,]=Kls$Fk
#print(lambda(Kernals[a,1,,]))
debut=(a-1)*MatrixDim+1
fin=debut+(MatrixDim-1)
GlobMatrIPM[1:MatrixDim,(debut:fin)]=Kls$Fk
GlobMatrIPM[((fin+1):(fin+MatrixDim)),(debut:fin)]=Kls$Pk
}
Kls=K.fnc0(AgeMax,MatrixDim,RecrRate, Beta_test)
Kernals[AgeMax,1,,]=Kls$M
Kernals[AgeMax,2,,]=Kls$Pk
Kernals[AgeMax,3,,]=Kls$Fk
#print(lambda(Kernals[a,1,,]))
debut=(AgeMax-1)*MatrixDim+1
fin=debut+(MatrixDim-1)
GlobMatrIPM[1:MatrixDim,(debut:fin)]=Kls$Fk
GlobMatrIPM[(debut:fin),(debut:fin)]=Kls$Pk
return(lambda(GlobMatrIPM))
}
obs_lambda=super_matrix(0) # growthrate values reported in table 1
print(obs_lambda)
print(obs_beta)
mean_size=mean(centauree_data_complet$Size0Mars[which(centauree_data_complet$Flowering0==1)])
sd_size=sd(centauree_data_complet$Size0Mars[which(centauree_data_complet$Flowering0==1)])
print(mean_size)
print(sd_size)
mean_age=mean(centauree_data_complet$age0[which(centauree_data_complet$Flowering0==1)], na.rm=T)
sd_age=sd(centauree_data_complet$age0[which(centauree_data_complet$Flowering0==1)], na.rm=T)
print(mean_age)
print(sd_age)
rm(list=ls())
library(knitr)
library(spaMM)
library(tidyverse)
library(splines)
library(foreach)
library(doParallel)
setwd("/media/loic/Commun/0Travail/Stage 2025 ISEM/Models")
centauree_data <- read.csv("donnesIPM_short.csv")
centauree_data_complet <- read.csv("donnesIPM.csv")
#Supprimer plantes dont l'age est inconnu
centauree_data <- centauree_data[!is.na(centauree_data$age0), ]
centauree_data$age1 <- ifelse(centauree_data$Stage1=="V",centauree_data$age0+1,NA)
#Forcer l'age maximal à 8
length(centauree_data$age0[centauree_data$age0 >= 8])
centauree_data$age0[centauree_data$age0 > 8] <- 8
spaMM.options(separation_max=70)
# Liste initiale des effets aléatoires
random_effects <- c("year", "Pop", "Nrw", "1", "Size0Mars", "age0", "Size0Mars + age0")
# Les parties pour combiner
r_effects <- random_effects[1:3]  # éléments : "year", "Pop", "Nrw"
f_effects <- random_effects[4:7]   # éléments "1", "Size0Mars", "age0", "Size0Mars + age0"
# Générer toutes les combinaisons (fixed effects | random effect)
ran_combinations <- sapply(f_effects, function(feffect) {
sapply(r_effects, function(reffect) {
paste0("(", feffect, "|", reffect, ")")
})
})
random_effects <- c(as.vector(ran_combinations),"(1|Pop:year)","1")
size_effects <- c("Size0Mars","poly(Size0Mars,2)","bs(Size0Mars,df=4,degree=2)","bs(Size0Mars,df=3,degree=2)",
"poly(Size0Mars,3)","bs(Size0Mars,df=5,degree=3)","poly(Size0Mars,4)")
age_effects <- c("age0","poly(age0,2)","bs(age0,degree=2,knots=6.5)",
"poly(age0,3)","bs(age0,degree=3,knots=6.5)","bs(age0,degree=3,knots=c(1.5,6.5))", "poly(age0,4)")
age_effects2 <- c("age0","poly(age0,2)","bs(age0,degree=2,knots=6.5)",
"poly(age0,3)","bs(age0,degree=3,knots=6.5)", "poly(age0,4)")
# Fonction pour vérifier les doublons
is_valid_combination <- function(comb) {
comb <- sort(comb)  # Trier pour vérifier l'ordre
if ("(1|year)" %in% comb && "(Size0Mars + age0|year)" %in% comb) return(FALSE)
if ("(1|year)" %in% comb && "(age0|year)" %in% comb) return(FALSE)
if ("(1|year)" %in% comb && "(Size0Mars|year)" %in% comb) return(FALSE)
if ("(Size0Mars|year)" %in% comb && "(Size0Mars + age0|year)" %in% comb) return(FALSE)
if ("(Size0Mars|year)" %in% comb && "(age0|year)" %in% comb) return(FALSE)
if ("(age0|year)" %in% comb && "(Size0Mars + age0|year)" %in% comb) return(FALSE)
if ("(1|Pop)" %in% comb && "(Size0Mars + age0|Pop)" %in% comb) return(FALSE)
if ("(1|Pop)" %in% comb && "(age0|Pop)" %in% comb) return(FALSE)
if ("(1|Pop)" %in% comb && "(Size0Mars|Pop)" %in% comb) return(FALSE)
if ("(Size0Mars|Pop)" %in% comb && "(Size0Mars + age0|Pop)" %in% comb) return(FALSE)
if ("(Size0Mars|Pop)" %in% comb && "(age0|Pop)" %in% comb) return(FALSE)
if ("(age0|Pop)" %in% comb && "(Size0Mars + age0|Pop)" %in% comb) return(FALSE)
if ("(1|Nrw)" %in% comb && "(Size0Mars + age0|Nrw)" %in% comb) return(FALSE)
if ("(1|Nrw)" %in% comb && "(age0|Nrw)" %in% comb) return(FALSE)
if ("(1|Nrw)" %in% comb && "(Size0Mars|Nrw)" %in% comb) return(FALSE)
if ("(Size0Mars|Nrw)" %in% comb && "(Size0Mars + age0|Nrw)" %in% comb) return(FALSE)
if ("(Size0Mars|Nrw)" %in% comb && "(age0|Nrw)" %in% comb) return(FALSE)
if ("(age0|Nrw)" %in% comb && "(Size0Mars + age0|Nrw)" %in% comb) return(FALSE)
if ("(age0|Nrw)" %in% comb) return(FALSE)
if ("(Size0Mars|Nrw)" %in% comb) return(FALSE)
if ("(Size0Mars + age0|Nrw)" %in% comb) return(FALSE)
if ("(1|Pop:year)" %in% comb) return(FALSE)
if (!"1" %in% comb) return(FALSE)
return(TRUE)
}
# Fonction qui retire les toutes les combinaisons avec effet aléatoire individus
is_valid2 <- function(comb){
if ("(1|Nrw)" %in% comb) return(FALSE)
return(TRUE)
}
# Fonction qui retire les combinaisons qui ne fonctionnent pas où il y a l'effet aléatoire individu (pour la survie age>1)
is_valid_Nrw <- function(comb){
if ("(1|Nrw)" %in% comb && any(grepl("^bs", comb))) return(FALSE)
if ("(1|Nrw)" %in% comb && "(Size0Mars + age0|year)" %in% comb) return(FALSE)
if ("(1|Nrw)" %in% comb && "(age0|year)" %in% comb) return(FALSE)
if ("(1|Nrw)" %in% comb && "(Size0Mars|year)" %in% comb) return(FALSE)
if ("(1|Nrw)" %in% comb && "(Size0Mars + age0|Pop)" %in% comb) return(FALSE)
if ("(1|Nrw)" %in% comb && "(age0|Pop)" %in% comb) return(FALSE)
if ("(1|Nrw)" %in% comb && "(Size0Mars|Pop)" %in% comb) return(FALSE)
return(TRUE)
}
# Fonction qui retire les combinaisons où il y a une fonction bs() et l'effet
# aléatoire individu (ces combinaisons ne fonctionnent pas)
is_valid_Nrw2 <- function(comb){
if ("(1|Nrw)" %in% comb && any(grepl("^bs", comb))) return(FALSE)
return(TRUE)
}
# Fonction qui retire les combinaisons avec age dans les effets aléatoires
is_valid_rage <- function(comb){
if ("(age0|Pop)" %in% comb) return(FALSE)
if ("(Size0Mars + age0|Pop)" %in% comb) return(FALSE)
if ("(age0|year)" %in% comb) return(FALSE)
if ("(Size0Mars + age0|year)" %in% comb) return(FALSE)
return(TRUE)
}
combinations <- list()
# Combinaisons de tous les effets aléatoires
for (n in 1:length(random_effects)) {
combinations <- c(combinations, combn(random_effects, n, simplify = FALSE))
}
combi <- Filter(is_valid_combination, combinations)
combinations <- combi
# Ajouter combinaisons avec size
for (s in size_effects) {
for (combo in combi) {
combinations <- c(combinations, list(c(s, combo)))
}
}
combi_surv1 <- combinations
combi2 <- combinations
combi <- combinations
# Ajouter combinaisons avec age
for (a in age_effects) {
for (combo in combinations) {
combi <- c(combi, list(c(a, combo)))
}
}
# Ajouter combinaisons avec age 2 (pour la survie age 2+)
for (a in age_effects2) {
for (combo in combinations) {
combi2 <- c(combi2, list(c(a, combo)))
}
}
validNrwSurv <- Filter(is_valid_Nrw,combi2) # Combinaisons fonctionelles (comprenant l'effet individu) - pour la survie
validNrw2 <- Filter(is_valid_Nrw2,combi) # Combinaisons fonctionelles (comprenant l'effet individu) - pour la floraison
valid <- Filter(is_valid2,combi) # Combinaisons sans effet individu
combi_surv1 <- Filter(is_valid2,combi_surv1)
combi_surv1 <- Filter(is_valid_rage,combi_surv1) # Combinaison pour survie plantules
combi_plantule <- c("1","1 + (1|year) + (1|Pop) + (1|Pop:year)","1 + (1|year) + (1|Pop)","1 + (1|year) + (1|Pop:year)","1 + (1|Pop) + (1|Pop:year)","1 + (1|year)","1 + (1|Pop)","1 + (1|Pop:year)")
# Remplace size par log(size)
combi_growth_log <- lapply(valid, function(x) gsub("Size0Mars", "log(Size0Mars)", x))
combi_growthNrw_log <- lapply(validNrw2, function(x) gsub("Size0Mars", "log(Size0Mars)", x))
combi_resvar <- c("1","log(age0)","log(Size0Mars)","log(Size0Mars) + log(age0)")
Growthglm1 <- fitme(Size1Mars ~ 1 + poly(Size0Mars,4) + poly(age0,3) + (Size0Mars|year) + (Size0Mars|Pop),
data=growthdata)
growthdata <- centauree_data[!is.na(centauree_data$Size1Mars), ]
growthdata <- growthdata[growthdata$Size1Mars != 0, ]
Growthglm1 <- fitme(Size1Mars ~ 1 + poly(Size0Mars,4) + poly(age0,3) + (Size0Mars|year) + (Size0Mars|Pop),
data=growthdata)
Growthglm1
Growthglm1 <- fitme(Size1Mars ~ 1 + poly(Size0Mars,4) + poly(age0,3) + (Size0Mars|year) + (Size0Mars|Pop) +(1|Nrw),
data=growthdata,verbose=c(TRACE=TRUE))
Growthglm1
View(validNrw2)
Growthglm1 <- fitme(Size1Mars ~ 1 + bs(Size0Mars,df=4) + poly(age0,3) + (Size0Mars|year) + (Size0Mars|Pop) +(1|Nrw),
data=growthdata,verbose=c(TRACE=TRUE))
Growthglm1
View(combi2)
Growthglm1 <- fitme(Size1Mars ~ 1 + poly(Size0Mars,4) + bs(age0,df=4) + (Size0Mars|year) + (Size0Mars|Pop) +(1|Nrw),
data=growthdata,verbose=c(TRACE=TRUE))
combi_resvar
resp <- "Size1Mars"
combi <- combi2
ls <- length(combi)
lv <- length(combi_resvar)
resp <- "Size1Mars"
combi <- combi2
ls <- length(combi)
lv <- length(combi_resvar)
cl <- makeCluster(10)
registerDoParallel(cl)
AICresult <- foreach(i = 1:ls, .packages=c("splines","spaMM"), .combine = cbind)  %:%
foreach (j = 1:lv, .packages=c("splines","spaMM"), .combine = cbind) %dopar% {
set_effects <- combi[i]
var_effect <- combi_resvar[j]
effect_formula <- paste(unlist(set_effects), collapse = "+")
formula <- as.formula(paste(resp, "~", effect_formula))
formula_resvar <- as.formula(paste("~", var_effect))
fit <- fitme(formula, data = growthdata, resid.model = formula_resvar,family = gaussian(log))
extractAIC(fit)[2]
}
stopCluster(cl)
Growthglm1 <- fitme(Size1Mars ~ 1 + poly(Size0Mars,4) + bs(age0,df=4) + (Size0Mars|year) + (Size0Mars|Pop) +(1|Nrw),
data=growthdata,resid.model =~log(Size0Mars)+log(age0),verbose=c(TRACE=TRUE))
Growthglm1
resp <- "Size1Mars"
combi <- combi2
ls <- length(combi)
lv <- length(combi_resvar)
cl <- makeCluster(10)
registerDoParallel(cl)
AICresult <- foreach(i = 1:ls, .packages=c("splines","spaMM"), .combine = cbind)  %:%
foreach (j = 1:lv, .packages=c("splines","spaMM"), .combine = cbind) %dopar% {
set_effects <- combi[i]
var_effect <- combi_resvar[j]
effect_formula <- paste(unlist(set_effects), collapse = "+")
formula <- as.formula(paste(resp, "~", effect_formula))
formula_resvar <- as.formula(paste("~", var_effect))
fit <- fitme(formula, data = growthdata, resid.model = formula_resvar,family = gaussian(log))
extractAIC(fit)[2]
}
stopCluster(cl)
