sizesObserved=sizesObserved[which(SD!=0)]
SDlm=lm(SD ~ sizesObserved)
# growthdata <- centauree_data %>%
#   filter(!is.na(Size1Mars),Size1Mars!=0,!is.na(Age)) %>%
#   mutate(logSize1Mars = log(Size1Mars),
#          logSize0Mars = log(Size0Mars))
# sizesObserved=sort(unique(growthdata$logSize0Mars, na.rm=T))
# SD=NULL
# for (i in 1:length(sizesObserved)){
#   SD[i] <- sd(growthdata$logSize1Mars[growthdata$logSize0Mars==(sizesObserved[i])])
#   }
# SDlm=lm(SD ~ sizesObserved)
#Growth function
Gyx0 <- function (y, x, a) { # Méthode midpoint
fake_data$Age <- a #Fixe l'age
fake_data$Size0Mars <- unique(x) #Fixe la taille
mu <- predict(Growthglm1, fake_data, allow.new.levels = T, residVar=TRUE) #Prédit les log(taille) à t+1 possibles
mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean) #Calcule la moyenne des log(taille)t+1
M <- matrix(mu2$V1, length(x), length(y), byrow = T)
usd <- predict(SDlm, data.frame(sizesObserved=x))
return(dnorm(log(y), mean = M, sd = usd)) #Proba qu'un individu soit de taille y à t+1 sachant la moyenne et la variance
}
Gyx1 <- function(ysup,yinf,x,a){ # Croissance CDF log
yinf[1] <- -Inf
ysup[length(ysup)] <- Inf
fake_data <- expand.grid(
year = annees,
Pop = populations,
Size0Mars = unique(x),
Age = a)
mu <- exp(predict(Growthglm12, fake_data, allow.new.levels = T)) #Prédit les taille à t+1 possibles
mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean) #Calcule la moyenne des taillet+1
usd <- sqrt(0.27795)
usd <- sqrt(exp(-0.8872301-0.4646620*log(unique(x))))
cdf.sup <- mapply(pnorm, mean = mu2$V1, sd = usd, MoreArgs = list(q=ysup))
cdf.inf <- mapply(pnorm, mean = mu2$V1, sd = usd, MoreArgs = list(q=yinf))
return(cdf.sup - cdf.inf)}
Gyx2 <- function(ysup,yinf,x,a){ # Croissance CDF sans log
yinf[1] <- -Inf
ysup[length(ysup)] <- Inf
fake_data <- expand.grid(
year = annees,
Pop = populations,
Size0Mars = unique(x),
Age = a)
mu <- predict(Growthglm2, fake_data, allow.new.levels = T) #Prédit les taille à t+1 possibles
mu2 <- aggregate(mu, list(fake_data$Size0Mars), mean) #Calcule la moyenne des taillet+1
usd <- sqrt(exp(1.0462608+0.5367287*log(unique(x))))
cdf.sup <- mapply(pnorm, mean = mu2$V1, sd = usd, MoreArgs = list(q=ysup))
cdf.inf <- mapply(pnorm, mean = mu2$V1, sd = usd, MoreArgs = list(q=yinf))
# cdf.sup <- mapply(pnorm, q=ysup, MoreArgs = list(mean = mu2$V1, sd = usd))
# cdf.inf <- mapply(pnorm, q=yinf, MoreArgs = list(mean = mu2$V1, sd = usd))
return(cdf.sup - cdf.inf)}
#Seedling size density
densSeedl <- function(ysup, yinf) {
yinf[1] <- -Inf
ysup[length(ysup)] <- Inf
mu <- predict(Pltglm1, newdata = fake_data)[, 1]
shape <- 1 / Pltglm1$phi
mu <- mean(mu)
scale <- mu * Pltglm1$phi
cdf.sup <- pgamma(ysup, shape = shape, scale = scale)
cdf.inf <- pgamma(yinf, shape = shape, scale = scale)
return(cdf.sup - cdf.inf)
}
Pop <- populations
year <- annees
Estbli <- function(Pop=Pop, year=annees){
fake_data <- expand.grid(
year = year,
Pop = Pop)
mu <- mean(predict(Estbglm1, newdata= fake_data))
# sample(predict(Estbglm1),1)
return(mu)
}
#Combine fecundity and flowering probability
fyx02 <- function(x , a, Estbl, Beta = 0) {
#flowering probability:
p.flow <- flr1(x, a, Beta)
#number of capitula per flowering plant
n.captl <- numbofcap(x, a)
#survival probability
if(a==1){p.surv <- sx01(x,1)}
if(a!=1){p.surv <- sx02(x,a)}
# p.surv <- ifelse(a==1,sx01(x,a),sx02(x,a))
# p.surv <- matrix(p.surv, MatrixDim, MatrixDim, byrow = T)
Fyx0 <- p.flow * n.captl * Estbl
# * p.surv
return(Fyx0)
}
fyx0 <- function(y, x , a, Estbl, Beta = 0, intervalle) {
#flowering probability:
p.flow <- flr1(x, a, Beta)
#number of capitula per flowering plant
n.captl <- numbofcap(x, a)
#Seedlings Size distribution
ProporSeedlSize <- densSeedl2(y,intervalle)
#survival probability
sx0 <- ifelse(a==1,sx01,sx02)
p.surv <- sx0(x,a)
Fyx0 <- ifelse((p.flow * n.captl * Estbl * ProporSeedlSize) >= 0,
p.flow * n.captl * Estbl * ProporSeedlSize * p.surv,
0)
return(Fyx0)
}
n.size <- 50
age <- 2
estbl <- RecrRate
Beta <- 0
K.fnc0 <- function(age, n.size, estbl, Beta=0){
minsize <-  0.5
maxsize <-  25
maxsize1 <- 15
h <-  (maxsize - minsize) / n.size
h1 <-  (maxsize1 - minsize) / n.size
b <- minsize + c(0:n.size) * h
#sizes for an individual of age a
#midpoint
ymid.a = 0.5 * (b[1:n.size] + b[2:(n.size + 1)])
#intervals
yI.a <- matrix(nrow = n.size, ncol = 2)
for (i in 1:n.size){
yI.a[i,1] <- b[i]
yI.a[i,2] <- b[i+1]
}
b1 = minsize + c(0:n.size) * h1
#sizes for an individual of age 1
#midpoint
ymid.1 = 0.5 * (b1[1:n.size] + b1[2:(n.size + 1)])
#intervals
yI.1 <- matrix(nrow = n.size, ncol = 2)
for (i in 1:n.size){
yI.1[i,1] <- b1[i]
yI.1[i,2] <- b1[i+1]
}
if(age==1){h <- h1
ymid.a <- ymid.1
# yI.a <- yI.1
}
#The growth kernel
G <- Gyx2(ysup=yI.a[,2], yinf=yI.a[,1], x=ymid.a, a=age)
#The survival-growth kernel #remove flowering plants since they died
sx0 <- ifelse(age==1,sx01,sx02)
if(age==1){surv <- sx01(ymid.a,1)}
if(age!=1){surv <- sx02(ymid.a,age)}
S_flr <- surv*(1-flr0(ymid.a,age,Beta))
# S_flr <- sx0(ymid.a,age)*(1-flr0(ymid.a,age,Beta))
Ps <- sweep(G, MARGIN=2, S_flr, '*')
P <- matrix(Ps, nrow=n.size)
#Fecundity
ProporSeedlSize <- densSeedl(ysup=yI.1[,2],yinf=yI.1[,1])
feco <- fyx02(x = ymid.a, a = age, Estbl = estbl, Beta = Beta)
Fec <- sweep(feco, MARGIN=1, ProporSeedlSize, '*')
IPMk <- P + Fec
return(list(M=IPMk,Pk=P,Fk=Fec))
}
super_matrix = function(Beta_test){
Pk <- matrix(data = NA, nrow = MatrixDim, ncol = MatrixDim)
Fk <- matrix(data = NA, nrow = MatrixDim, ncol = MatrixDim)
Mk <- matrix(data = NA, nrow = MatrixDim, ncol = MatrixDim)
Kernals <- array(data = 0, dim = c(AgeMax, 3, MatrixDim, MatrixDim))
GlobMatrIPM <- array(0, dim = c((AgeMax * MatrixDim), (AgeMax * MatrixDim)))
# estbl <- Estbli(Pop,annees)
for (a in (1:(AgeMax - 1))){
Kls <- K.fnc0(a, MatrixDim, estbl, Beta_test)
Kernals[a, 1, , ] <- Kls$M
Kernals[a, 2, , ] <- Kls$Pk
Kernals[a, 3, , ] <- Kls$Fk
# print(lambda(Kernals[a, 1, , ]))
debut <- (a - 1) * MatrixDim + 1
fin <- debut + (MatrixDim - 1)
GlobMatrIPM[1:MatrixDim, (debut:fin)] <- Kls$Fk
GlobMatrIPM[((fin + 1):(fin + MatrixDim)), (debut:fin)] <- Kls$Pk
}
Kls <- K.fnc0(AgeMax, MatrixDim, estbl, Beta_test)
Kernals[AgeMax, 1, , ] <- Kls$M
Kernals[AgeMax, 2, , ] <- Kls$Pk
Kernals[AgeMax, 3, , ] <- Kls$Fk
# print(lambda(Kernals[a,1,,]))
debut <- (AgeMax - 1) * MatrixDim + 1
fin <- debut + (MatrixDim - 1)
GlobMatrIPM[1:MatrixDim, (debut:fin)] <- Kls$Fk
GlobMatrIPM[(debut:fin), (debut:fin)] <- Kls$Pk
return(GlobMatrIPM)
}
Beta <- 0
MatrixIPM <- super_matrix(0) # growthrate values reported in table 1
print(lambda(MatrixIPM))
A <- eigen.analysis(MatrixIPM)
N <- matrix(ncol = 8, nrow = 50)
for (i in 1:8){
N[,i] <- A$stable.stage[(50*(i-1)+1):(50*i)]
}
# N <- 100000*N
minsize <-  0.5
maxsize <-  25
maxsize1 <- 15
n.size <- MatrixDim
h <-  (maxsize - minsize) / n.size
h1 <-  (maxsize1 - minsize) / n.size
b = minsize + c(0:n.size) * h
#sizes for an individual of age a
#midpoint
ymid.a = 0.5 * (b[1:n.size] + b[2:(n.size + 1)])
#intervals
yI.a <- matrix(nrow = n.size, ncol = 2)
for (i in 1:n.size){
yI.a[i,1] <- b[i]
yI.a[i,2] <- b[i+1]
}
b1 = minsize + c(0:n.size) * h1
#sizes for an individual of age 1
#midpoint
ymid.1 = 0.5 * (b1[1:n.size] + b1[2:(n.size + 1)])
#intervals
yI.1 <- matrix(nrow = n.size, ncol = 2)
for (i in 1:n.size){
yI.1[i,1] <- b1[i]
yI.1[i,2] <- b1[i+1]
}
V <- function(age){
return(N[(50*(age-1)+1):(50*age)])
}
minsize <-  0.5
maxsize <-  25
maxsize1 <- 15
n.size <- MatrixDim
h <-  (maxsize - minsize) / n.size
h1 <-  (maxsize1 - minsize) / n.size
b = minsize + c(0:n.size) * h
#sizes for an individual of age a
#midpoint
ymid.a = 0.5 * (b[1:n.size] + b[2:(n.size + 1)])
#intervals
yI.a <- matrix(nrow = n.size, ncol = 2)
for (i in 1:n.size){
yI.a[i,1] <- b[i]
yI.a[i,2] <- b[i+1]
}
b1 = minsize + c(0:n.size) * h1
#sizes for an individual of age 1
#midpoint
ymid.1 = 0.5 * (b1[1:n.size] + b1[2:(n.size + 1)])
#intervals
yI.1 <- matrix(nrow = n.size, ncol = 2)
for (i in 1:n.size){
yI.1[i,1] <- b1[i]
yI.1[i,2] <- b1[i+1]
}
V <- function(age){
return(N[(50*(age-1)+1):(50*age)])
}
Flry <- 0
FlrI <- sum(flr0(ymid.1,1)*V(1))
Z <- rep(NA, 50)
for (a in 2:8) {
FlrI <- FlrI + sum(flr0(ymid.a, a) * V(a))
}
for (i in 1:MatrixDim) {
Flry <- sum(flr0(ymid.1[i],1)*V(1)[i])
for (a in 2:8) {
Flry <- Flry + flr0(ymid.a[i], a) * V(a)[i]
}
Z[i] <- Flry/FlrI
}
flower_data <- centauree_data[centauree_data$Flowering==1 & !is.na(centauree_data$Flowering),]
flower_data <- flower_data %>%
group_by(Size0Mars) %>%
summarise(n_fleuri = n()) %>%
mutate(Wobs = n_fleuri / sum(n_fleuri),
Size=Size0Mars) %>% dplyr::select(!n_fleuri) %>%
dplyr::select(!Size0Mars)
tibble(Size = seq(0.5,25,0.5),
West = Z) %>%
left_join(flower_data,join_by(Size)) %>%
ggplot(aes(x = Size)) +
geom_bar(aes(y = Wobs), stat = "identity", fill = "steelblue",color="black") +
geom_line(aes(y = West), color = "red", linewidth = 1) +
labs(x = "Size at flowering", y = "Density")+
theme_bw()+
theme(
axis.title.x = element_text(size = 16),  # Taille du titre axe X
axis.title.y = element_text(size = 16),  # Taille du titre axe Y
axis.text.x = element_text(size = 14),   # Taille des graduations axe X
axis.text.y = element_text(size = 14)    # Taille des graduations axe Y
)
Flry <- 0
FlrI <- sum(sx01(ymid.1,1)*flr0(ymid.1,1)*V(1))
Z <- rep(NA, 50)
for (a in 2:8) {
FlrI <- FlrI + sum(sx02(ymid.a, a) * flr0(ymid.a, a) * V(a))
}
for (i in 1:MatrixDim) {
Flry <- sum(ymid.1[i]*sx01(ymid.1[i],1)*flr0(ymid.1[i],1)*V(1)[i])
for (a in 2:8) {
Flry <- Flry + sum(ymid.a[i] * sx02(ymid.a[i], a) * flr0(ymid.a[i], a) * V(a)[i])
}
W[i] <- Flry/FlrI
}
Flry <- 0
FlrI <- sum(sx01(ymid.1,1)*flr0(ymid.1,1)*V(1))
Z <- rep(NA, 50)
for (a in 2:8) {
FlrI <- FlrI + sum(sx02(ymid.a, a) * flr0(ymid.a, a) * V(a))
}
for (i in 1:MatrixDim) {
Flry <- sum(ymid.1[i]*sx01(ymid.1[i],1)*flr0(ymid.1[i],1)*V(1)[i])
for (a in 2:8) {
Flry <- Flry + sum(ymid.a[i] * sx02(ymid.a[i], a) * flr0(ymid.a[i], a) * V(a)[i])
}
W[i] <- Flry/FlrI
}
W <- c()
for (i in 1:MatrixDim) {
Flry <- sum(ymid.1[i]*sx01(ymid.1[i],1)*flr0(ymid.1[i],1)*V(1)[i])
for (a in 2:8) {
Flry <- Flry + sum(ymid.a[i] * sx02(ymid.a[i], a) * flr0(ymid.a[i], a) * V(a)[i])
}
W[i] <- Flry/FlrI
}
West <- W/(sum(W))
flower_data <- centauree_data[centauree_data$Flowering==1 & !is.na(centauree_data$Flowering),]
flower_data <- flower_data %>%
group_by(Size0Mars) %>%
summarise(n_fleuri = n()) %>%
mutate(Wobs = n_fleuri / sum(n_fleuri),
Size=Size0Mars) %>% dplyr::select(!n_fleuri) %>%
dplyr::select(!Size0Mars)
tibble(Size = seq(0.5,25,0.5),
West = West) %>%
left_join(flower_data,join_by(Size)) %>%
ggplot(aes(x = Size)) +
geom_bar(aes(y = Wobs), stat = "identity", fill = "steelblue",color="black") +
geom_line(aes(y = West), color = "red", linewidth = 1) +
labs(x = "Size", y = "Density")+
theme_bw()+
theme(
axis.title.x = element_text(size = 16),  # Taille du titre axe X
axis.title.y = element_text(size = 16),  # Taille du titre axe Y
axis.text.x = element_text(size = 14),   # Taille des graduations axe X
axis.text.y = element_text(size = 14)    # Taille des graduations axe Y
)
N1t1 <- sum(MatrixIPM[i,1:50] * V(1))
N3t0 <- 0
for(a in 2:8){
N3t0 <- N3t0 + sum(V(a)*flr0(ymid.a,a))
for (i in 1:MatrixDim){
N1t1 <- N1t1 + sum(MatrixIPM[i,((a-1)*50+1):(a*50)] * V(a))
}
}
fs0 <- N1t1/N3t0
fs0
N2t1 <- sum(MatrixIPM[i,1:50] * V(1))
N1t0 <- sum(V(1))
for (i in 1:MatrixDim){
N2t1 <- N2t1 + sum(MatrixIPM[50+i,] * V(1) * (1-flr0(ymid.a,2)))
}
s1_1a1 <- N2t1/N1t0
s1_1a1
N2t1 <- sum(MatrixIPM[i,1:50] * V(1))
N1t0 <- sum(V(1))
for (i in 1:MatrixDim){
N2t1 <- N2t1 + sum(MatrixIPM[50+i,] * V(1) * flr0(ymid.a,2))
}
s1_a1 <- N2t1/N1t0
s1_a1
N2t1 <- 0
N2t0 <- sum(V(8)*(1-flr0(ymid.a,8)))
for(a in 2:7){
N2t0 <- N2t0 + sum(V(a)*(1-flr0(ymid.a,a)))
for (i in 1:MatrixDim){
N2t1 <- N2t1 + sum(MatrixIPM[(a*50+i),] * V(a) * (1-flr0(ymid.a,a+1)))
}
}
s2_1a2 <- N2t1/N2t0
s2_1a2
N2t1 <- 0
N2t0 <- sum(V(8)*(1-flr0(ymid.a,8)))
for(a in 2:7){
N2t0 <- N2t0 + sum(V(a)*(1-flr0(ymid.a,a)))
for (i in 1:MatrixDim){
N2t1 <- N2t1 + sum(MatrixIPM[(a*50+i),] * V(a) * flr0(ymid.a,a+1))
}
}
s2_a2 <- N2t1/N2t0
s2_a2
IPM <- matrix(c(0,s1_1a1,s1_a1,0,s2_1a2,s2_a2,fs0,0,0),nrow=3,ncol=3)
load("matrice_globale.RData")
MPM <- A
rm(A)
IPM
MPM
mu_size <- sum(ymid.1*V(1)*flr0(ymid.1,1))
mu_a <- sum(V(1)*flr0(ymid.1,1))
mu2 <- sum(V(1)*flr0(ymid.1,1))
for(a in 2:8){
mu_size <- mu_size + sum(ymid.a*V(a)*flr0(ymid.a,a))
mu_a <- mu_a + sum(a*V(a)*flr0(ymid.a,a))
mu2 <- mu2 + sum(V(a)*flr0(ymid.a,a))
}
mu_size <- mu_size/mu2
mu_a <- mu_a/mu2
mu_size
mu_a
#Utilisation du modèle matriciel
load("matricesperyear.RData") #Matrices entre 1995 - 2022 donc 27 matrices
load("matrice_globale.RData") #Matrice globale sans tenir compte des années => utilisée pour la distribution stable
library(popbio)
library(ggplot2)
#Utilisation du modèle IPM transformé dans le même format que le modèle matriciel
A <- IPM #IPM est défini plus haut
load("IPMEstimatedMatrix.RData")
matrices <- IPMyear
#nbre de plantes en fleurs observés entre 1995 et 2022, pas de mesure en 2008
obs <- c(494,420,604,638,343,490,631,482,815,435,613,794,210,NA,322,216,277,386,565,254,369,407,148,162,310,248,407,214)
year=seq(1995,2022)
ev=eigen(A)
W <- abs(Re(ev$vectors[,1]))
W=W/sum(W)
NbrFleurs=obs[1] #valeur en 1995
N0=round(W*NbrFleurs/W[3]) #distribution stable estimée avec la matrice globale
N0
nbf=matrix(NA, 3,28)
nbf[,1] = N0
for (i in 1:27)
{
nbf[,i+1] = matrices[[i]]%*%nbf[,i]
}
plot(obs,nbf[3,], xlim=c(0,900), ylim=c(0,900), xlab="Nombre de plantes en fleurs observé", ylab = "Nombre estimé")
abline(a=0,b=1)
plot(obs ~ year, type='l', xlab="Année", ylab="Nombre", ylim=c(0,900))
legend(300,300,"Nombre observé", lty=1, col="black")
points(nbf[3,] ~ year, type='l', col="red")
legend(300,320,"Nombre estimé", lty=1, col="red")
diff_obs <- obs[-1]/obs[-28]
diff_estim <- nbf[3,-1]/nbf[3,-28]
plot(diff_obs ~ year [-28], ylim=c(0,2), type='l', col="black")
points(diff_estim ~ year [-28], type='l', col="red")
# points(lam$lambda[-28] ~ year [-28], type='l', col="red")
#Fonction pour simuler les trajectoires des tailles de pop########
# (récuperer de Popbio et modifier pour mettre une fécondite tirée dans une Poissonnienne au lieu d'une binomiale)
multiresultm1=function (n, T, F, varF = NULL)
{
clas <- length(n)
death <- 1 - colSums(T)
T <- rbind(T, death)
outcome <- matrix(0, nrow(T), clas)
for (j in 1:clas) {
Tj <- T[, j]
ni <- n[j]
ind <- matrix(1, 1, ni)
pp <- cumsum(Tj/sum(Tj))
rnd <- runif(ni, min = 0, max = 1)
for (ii in 1:length(Tj)) {
ind <- ind + (rnd > pp[ii])
}
for (ii in 1:length(Tj)) {
outcome[ii, j] <- sum(ind == ii)
}
}
if (length(varF) != 0) {
offspring <- matrix(0, clas, clas)
for (j in 1:clas) {
fj <- F[, j]
if (max(fj) > 0) {
ni <- n[j]
for (i in 1:length(fj)) {
if (F[i, j] > 0) {
rndfert <- lnorms(ni, F[i, j], varF[i, j])
offspring[i, j] <- sum(rndfert)
}
}
}
}
}
else {
offspring <- matrix(0, clas, clas)
for (j in 1:clas) {
fj <- F[, j]
if (max(fj) > 0) {
ni <- n[j]
for (i in 1:length(fj)) {
if (F[i, j] > 0) {
rndbirth <- rpois(1, F[i, j])#cette ligne a ete modifiee (rbinom(ni,1,F(i,j)))
offspring[i, j] <- sum(rndbirth)*n[j]#
}
}
}
}
}
multiresultm <- matrix(rowSums(offspring) + rowSums(outcome[1:clas, ]), clas, 1, dimnames = list(rownames(F), "t+1"))
multiresultm
}
nbf_stoch=matrix(NA, 3,28)
nbf_stoch[,1] = N0
nfleursstoch <- matrix(NA, 1000,28)
for (i in 1:1000) {
for (annee in 1:27)
{x <- splitA(matrices[[annee]])
nbf_stoch[,annee+1] = multiresultm1(nbf_stoch[,annee],x$T,x$F)
}
nfleursstoch[i,] <- nbf_stoch[3,]
}
moyenne <- colMeans(nfleursstoch)
sd_moyenne <- apply(nfleursstoch, 2, sd)
mesdonnees <- data.frame(year, moyenne, sd_moyenne, obs)
ggplot(mesdonnees, aes(x=year, y=moyenne)) +
geom_line(aes(y=moyenne), col="red") +
geom_point(aes(y=moyenne), col="red") +
geom_errorbar(aes(ymin=moyenne-sd_moyenne, ymax=moyenne+sd_moyenne), width = .1, col="red") +
geom_line(aes(y=obs), col="black") +
geom_point(aes(y=obs), col="black")
