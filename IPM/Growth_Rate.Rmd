---
title: "Global_IPM"
author: "Eric Imbert & Asma Hadjou Belaid"
date: "r Sys.Date()"
output:
  pdf_document: default
  html_document: default
  word_document: default
---

```{r setup, echo=FALSE}
rm(list=ls())
setwd("/media/loic/Commun/0Travail/Stage 2025 ISEM/Models")
library(popbio)
library(spaMM)

AgeMax=8
RecrRate=0.407 #recruitment rate
MatrixDim=50 #size of matrices for integration

#import
Dataglob=read.csv("donnesIPM.csv") #entire dataset
Datashort=read.csv("donnesIPM_short.csv") #same without seedlings


#Group plants >= AgeMax
Datashort$age0[Datashort$age0>=AgeMax]=AgeMax
Datashort$age1[Datashort$age1>=AgeMax]=AgeMax
Dataglob$age0[Dataglob$age0>=AgeMax]=AgeMax
Dataglob$age1[Dataglob$age1>=AgeMax]=AgeMax


#Add square(size)
Datashort$s2=(Datashort$Size0Mars)^2


#Construct fake dataset that will be used to integrate
year=unique(Datashort$year)
Pop=unique(Datashort$Pop)
Pop=gl(6,length(year),labels = Pop)
rer=data.frame(Pop,year)
rer$Index=1:(length(year)*6)
fake=do.call("rbind", replicate(MatrixDim, rer, simplify = FALSE))
fake=fake[order(fake$Index),]
fake$Size0Mars=NA
fake$age0=NA

rm(rer, Pop, year)
```


Age of flowering plants - will be used later to compute optimal growth rate
```{r}
weightAgeFlrPool=NULL
for ( a in 1:AgeMax )
{
  weightAgeFlrPool[a]= nrow(Datashort[which(Datashort$age0==a & Datashort$Flowering0==1),])
}
```


Seedling size distribution
```{r}
DatIpm=Dataglob[which(Dataglob$Size0Mars ==0 & Dataglob$Size1Mars !=0),]
DatIpm=Datashort[which(Datashort$age0 ==1),]

sizeSeedl=unique(DatIpm$Size1Mars[order(DatIpm$Size1Mars)])

vv=DatIpm$Size1Mars #Seedling size
Den=NULL
Width=NULL
UNIQ=unique(vv)
UNIQ=UNIQ[order(UNIQ)]

for ( i in 1:length(UNIQ))
{
  Den[i]=length(vv[which(vv==sizeSeedl[i])])/length(vv)
  Width[i]=length(vv[which(vv==sizeSeedl[i])]) #Number of observations for each size
}

dens=rep(Den,Width)
gg1=lm(log(1/dens)~rep(sizeSeedl,Width))

densSeedl=function(y,intervalle)
{   miny=min(y)
  maxy=max(y)
  SeedlgSize=exp(log(coef(gg1)[2])-y*coef(gg1)[2])/(exp(-coef(gg1)[2]*(miny-intervalle/2))-exp(-coef(gg1)[2]*(maxy+intervalle/2)))
  return(SeedlgSize)
}

```


All (generalized) linear models have been selected using AIC criterion.
Survival  : size + size² + (age|year) + (1|Pop) + (1|year)
Growth : size + (size²|year)+ age + (1|Pop) + (1| year)
Flowering : size + size² + age + (1|Pop) + (1|year)
Fecundity  : size 

```{r, echo=FALSE, warning=FALSE}
SurvData=Datashort[Datashort$Flowering0!=1,]
spaMM.options(separation_max=70)
#Fecundity
CptlLm0=fitme(Cptl0~ Size0Mars, data = Datashort[which(Datashort$Flowering0!=0),]) 

numbofcap=function(x,a) {
   fake$age0=a  
   fake$Size0Mars=unique(x)
   sortie=predict(CptlLm0, fake)
   sortie2=aggregate(sortie,list(fake$Size0Mars),mean)
   return(matrix(sortie2$V1,MatrixDim,MatrixDim,byrow = T ))
   }

#survival Probability Flowering Individuals are removed
SurvData=Datashort[Datashort$Flowering0!=1,]
SurvGlm=fitme(SurvieMars ~ Size0Mars + s2 + age0 + (1|Pop) + (1|year) + (age0|year) , family = binomial, data=SurvData)

sx0 <- function(x,a) {
  fake$age0=a
  fake$Size0Mars=x
  fake$s2=fake$Size0Mars^2
  sortie=predict(SurvGlm, fake ,re.form=~ (age0|year) + (1|year) + (1|Pop),  allow.new.levels=T)
  sortie2=aggregate(sortie,list(fake$Size0Mars),mean)
  return(sortie2$V1)}
      
#Flowering Probability 
#Beta = will be used to modify the intercept of the flowering function
#obs_beta = observed value
FlowGlm=fitme(Flowering0 ~ Size0Mars +  s2 + age0 + (1|Pop) +   (1|year), family=binomial, data=Datashort)
#extract Beta0
obs_beta=as.numeric(FlowGlm$fixef[1])
se_obs_beta=as.numeric(sqrt(diag(vcov(FlowGlm)))[1])


#Flowering function for The survival-growth kernel
flr0 <- function(x,a,Beta) {
  fake$age0=a
  fake$Size0Mars=unique(x)
  fake$s2=fake$Size0Mars^2
  sortie=plogis(predict(FlowGlm, fake, re.form= ~ (1|year) + (1|Pop), allow.new.levels=T, type="link") + Beta)
  sortie2=aggregate(sortie,list(fake$Size0Mars), mean)
  return(sortie2$V1)
}

#Flowering function for fecundity fyx0 - same function the difference is in the format of the output
flr1 <- function(x,a,Beta) {
  fake$age0=a
  fake$Size0Mars=unique(x)
  fake$s2=fake$Size0Mars^2
  sortie=plogis(predict(FlowGlm, fake, re.form= ~ (1|year) + (1|Pop), allow.new.levels=T, type="link") + Beta)
  sortie2=aggregate(sortie,list(fake$Size0Mars), mean)
  return(matrix(sortie2$V1,MatrixDim,MatrixDim,byrow = T ))
}


#Growth function
#Only data with a size in year t and year t+1
GrowData=Datashort[Datashort$Size1Mars!=0 & !is.na(Datashort$SurvieMars),]
GrowthGlm=fitme(Size1Mars ~ Size0Mars + s2 + (s2|year) + age0 + (1|Pop) + (1|year), data=GrowData)

GrowthGlmRD=fitme(Size1Mars ~ Size0Mars + s2 + (s2|year) + age0 + (1|Pop) + (1|year), 
                  resid.model=  ~ log(Size0Mars), data=GrowData)

#SD function
sizesObserved=sort(unique(Datashort$Size0Mars, na.rm=T))
SD=NULL
for (i in 1:length(sizesObserved))
  {SD[i]=sd(Datashort$Size1Mars[which(Datashort$Size1Mars !=0 & Datashort$Size0Mars==(sizesObserved[i]))])}
  SD=SD[which(SD!=0)]
  sizesObserved=sizesObserved[which(SD!=0)]
  SDlm=lm(SD ~ sizesObserved)

Gyx0 <- function (y,x,a) {
  fake$age0=a
  fake$Size0Mars=unique(x)
  fake$s2=fake$Size0Mars^2
  sortie <- predict(GrowthGlm,fake,re.form=~ (s2|year)+ (1|year)+ (1|Pop), allow.new.levels=T)
  sortie2=aggregate(sortie,list(fake$Size0Mars),mean)
  M<-matrix(sortie2$V1,MatrixDim,MatrixDim, byrow = T)
  Sdev <- predict(SDlm, data.frame(sizesObserved=x))
  return(dnorm(y,mean=M,sd=Sdev))
}

#Combine fecundity and flowering probability 
fyx0 <- function(y, x ,a, Estbl, Beta, intervalle) {
  #flowering probability:
  p.flow <-flr1(x,a, Beta)
  #number of capitula per flowering plant
  n.captl <-numbofcap(x,a)
  #Seedlings Size distribution
  ProporSeedlSize=densSeedl(y, intervalle)
  
  Fyx0=ifelse((p.flow*n.captl*Estbl*ProporSeedlSize) >=0,p.flow*n.captl*Estbl*ProporSeedlSize,0)
  return(Fyx0)
}
```

Compute kernel version modifiée par Adèle
```{r}
# Compute kernel
K.fnc0<-function(age,n.size,estbl, Beta) {
  # midpoints for an individual of age a
  minsize = max(0.5,min(Datashort$Size0Mars[Datashort$age0==age], na.rm=T)-0.5)  
  maxsize = 0.5+max(Datashort$Size0Mars[Datashort$age0==age], na.rm=T)
  h = (maxsize-minsize)/n.size
  b = minsize+c(0:n.size)*h
  y.a = 0.5*(b[1:n.size]+b[2:(n.size+1)])
  
  # midpoints for an individual of age a+1 (a1)
  if (age != AgeMax) {
    minsize = max(0.5,min(Datashort$Size0Mars[Datashort$age0==(age+1)], na.rm=T)-0.5)
    maxsize = 0.5+max(Datashort$Size0Mars[Datashort$age0==(age+1)], na.rm=T)
    ha1 = (maxsize-minsize)/n.size
    b = minsize+c(0:n.size)*ha1
    y.a1 = 0.5*(b[1:n.size]+b[2:(n.size+1)])
  } else {
    minsize = max(0.5,min(Datashort$Size0Mars[Datashort$age0==AgeMax], na.rm=T)-0.5)
    maxsize = 0.5+max(Datashort$Size0Mars[Datashort$age0==AgeMax], na.rm=T)
    ha1 = (maxsize-minsize)/n.size
    b = minsize+c(0:n.size)*ha1
    y.a1 = 0.5*(b[1:n.size]+b[2:(n.size+1)])
  }
  
  # midpoints for an individual of age 1
  minsize = max(0.5,min(Dataglob$Size0Mars[Dataglob$age0==1], na.rm=T)-0.5)  
  maxsize = 0.5+max(Dataglob$Size0Mars[Dataglob$age0==1], na.rm=T)
  h1 = (maxsize-minsize)/n.size
  b = minsize+c(0:n.size)*h1
  y.1 = 0.5*(b[1:n.size]+b[2:(n.size+1)])
  
  
  #The growth kernel
  G <- ha1*outer(y.a1, y.a, Gyx0, a=age)
 
####the following to make G sum to 1.0 in the event that there is some 'eviction' of individuals 
		for(i in 1:(n.size/2)) G[1,i]<-G[1,i]+1-sum(G[,i])
		for(i in (n.size/2+1):n.size) G[n.size,i]<-G[n.size,i]+1-sum(G[,i])	

  
  
  #The survival-growth kernel #remove  flowering plants since they died
  S_flr <- sx0(y.a,age)*(1-flr0(y.a,age, Beta))
  Ps <- sweep(G, MARGIN=2, S_flr, '*')
  P <- matrix(Ps, nrow=n.size)
  
  #Fecundity
  Fec <- h1*outer(y.1, y.a, fyx0 , a=age, Estbl=estbl, Beta=Beta, intervalle=h1) *sx0(y.1,1)
  IPMk=P+Fec
  return(list(M=IPMk,Pk=P,Fk=Fec))
 
}
```


the super matrix and growth rate
```{r}

super_matrix=function(Beta_test)
{

Pk=matrix(data=NA, nrow=MatrixDim, ncol=MatrixDim)
Fk=matrix(data=NA, nrow=MatrixDim, ncol=MatrixDim)
Mk=matrix(data=NA, nrow=MatrixDim, ncol=MatrixDim)
Kernals=array(data=0, dim=c(AgeMax,3,MatrixDim,MatrixDim))
GlobMatrIPM=array(0,dim=c((AgeMax*MatrixDim),(AgeMax*MatrixDim)))

for (a in (1:(AgeMax-1)))
{
  Kls=K.fnc0(a,MatrixDim,RecrRate, Beta_test)  
  Kernals[a,1,,]=Kls$M
  Kernals[a,2,,]=Kls$Pk
  Kernals[a,3,,]=Kls$Fk
  #print(lambda(Kernals[a,1,,])) 
  debut=(a-1)*MatrixDim+1
  fin=debut+(MatrixDim-1)
  GlobMatrIPM[1:MatrixDim,(debut:fin)]=Kls$Fk
  GlobMatrIPM[((fin+1):(fin+MatrixDim)),(debut:fin)]=Kls$Pk
 
}

Kls=K.fnc0(AgeMax,MatrixDim,RecrRate, Beta_test)  
  Kernals[AgeMax,1,,]=Kls$M
  Kernals[AgeMax,2,,]=Kls$Pk
  Kernals[AgeMax,3,,]=Kls$Fk
  #print(lambda(Kernals[a,1,,])) 
  debut=(AgeMax-1)*MatrixDim+1
  fin=debut+(MatrixDim-1)
  GlobMatrIPM[1:MatrixDim,(debut:fin)]=Kls$Fk
  GlobMatrIPM[(debut:fin),(debut:fin)]=Kls$Pk

  return(lambda(GlobMatrIPM))
  }

```


```{r}
obs_lambda=super_matrix(0) # growthrate values reported in table 1
print(obs_lambda)
print(obs_beta)

mean_size=mean(Dataglob$Size0Mars[which(Dataglob$Flowering0==1)])
sd_size=sd(Dataglob$Size0Mars[which(Dataglob$Flowering0==1)])
print(mean_size)
print(sd_size)

mean_age=mean(Dataglob$age0[which(Dataglob$Flowering0==1)], na.rm=T)
sd_age=sd(Dataglob$age0[which(Dataglob$Flowering0==1)], na.rm=T)

print(mean_age)
print(sd_age)

```
